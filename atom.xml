<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Min's Lounger]]></title>
  <link href="http://pliaohuimin.github.io/atom.xml" rel="self"/>
  <link href="http://pliaohuimin.github.io/"/>
  <updated>2014-10-30T11:45:42+08:00</updated>
  <id>http://pliaohuimin.github.io/</id>
  <author>
    <name><![CDATA[Mr.Liao]]></name>
    <email><![CDATA[pliaohuimin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[effective_c++:item17 在独立语句中将new出来的对象存放在智能指针中]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item17/"/>
    <updated>2014-10-28T20:03:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item17</id>
    <content type="html"><![CDATA[<p>考虑一下代码：</p>

<blockquote><pre><code>int priority();
void processWidget( std::tr1::shared_ptr&lt;Widget&gt; pw, int priority );
processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());
</code></pre></blockquote>

<p>在调用processWidget之前，编译器必须生成代码来完成下面三个事情：
&ndash; 调用priority
&ndash; 执行new Widget
&ndash; 调用 tr1::shared_ptr 构造函数</p>

<p>我们只能确保&#8221;new Widget&#8221;会在调用tr1::shared_ptr构造函数前被调用，但priority的调用会在第一，第二还是第三，我们是无法确定的。如果priority的调用是在第二，即：
&ndash; 执行new Widget
&ndash; 调用priority
&ndash; 调用 tr1::shared_ptr 构造函数</p>

<p>请考虑一下在调用priority时抛出异常，会出现什么情况。这种情况下，依旧会出现资源泄露。</p>

<p>想避免类似问题，方法也很简单：使用独立的语句来创建Widget并将它保存在智能指针中。然后再把智能指针传递给processWidget:</p>

<blockquote><pre><code>std::tr1::shared_ptr&lt;Widget&gt; pw( new Widget);
processWidget(pw,priority());
</code></pre></blockquote>

<h3>Things to Remember</h3>

<ul>
<li>在独立语句中，将new出来的对象保存在智能指针中。不这么做的话，一旦有异常抛出，可能会导致资源泄露。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item16 使用new和delete时应保持用法一致]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item16/"/>
    <updated>2014-10-28T20:03:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item16</id>
    <content type="html"><![CDATA[<p>当你使用new时，会发生两件事情，一个是分配内存，另一个是调用一个或者多个的构造函数。当你使用delete时，会发现另外两件事情，一个或者多个析构函数被调用，然后是内存空间的释放。这个涉及到一个问题，该删除多少个对象，这问题会决定多少个析构函数被调用。</p>

<p>实际上，这问题很简单：删除时指定是删除单个对象或者是一个数组。这个问题很重要，因为单对象的内存布局和数组对象的内存布局是不一样的。</p>

<p>规则很简单：如果你在new表达式中使用了[]，必须在delete中也使用[]。如果你在new中没使用[]，那么在delete中也不要使用[]。</p>

<p>在使用typedef时，需要特别注意，因为它意味着typedef的作者必须明文说明使用哪个形式的delete。来看看下面的例子：</p>

<blockquote><pre><code>typedef std::string AddressLines[4];
std::string *pal = newAddressLines;
</code></pre></blockquote>

<p>这时，必须使用数组形式的delete：</p>

<blockquote><pre><code>delete pal; //undefined
delete [] pal; //fine
</code></pre></blockquote>

<p>避免这个问题也很简单，方法就是使用C++库的string和vector。</p>

<h3>Things to Remember</h3>

<ul>
<li>如果你在new表达式中使用了[]，必须在delete中也使用[]。如果你在new中没使用[]，那么在delete中也不要使用[]。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item15 在资源管理类中提供原资源的存取接口]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item15/"/>
    <updated>2014-10-28T20:02:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item15</id>
    <content type="html"><![CDATA[<p>很多时候，APIs要求原资源作为参数，这时，你需要一种能将RAII类转换成原资源的途径。一般有两种方法：显性转换和隐性转换。</p>

<p>tr1::shared_ptr和auto_ptr都提供了一个get的成员方法来实现转换，返回智能指针指向对象的祼指针：</p>

<blockquote><p>int days = daysHeld(pInv.get());</p></blockquote>

<p>一般智能指针中都重载了->和*操作，这允许了隐性转换。</p>

<p>采用显性转换时（如get()），有时用户觉得使用起来不方便，就懒得使用资源管理类。使用隐性转换（如重载()操作符）会使API的调用看起来比较简单和自然。</p>

<p>但这会增加犯错的机会。</p>

<blockquote><pre><code>FontHandle getFont();
Font f1(getFont());
...
FontHandle f2 = f1; // meant to copy a Font object, but insterad implicitly converted f1 into its underlying FontHandle,then copy that
</code></pre></blockquote>

<p>现在一个FontHandle被f1管理着，但同时FontHandle也被f2使用。这几乎从来都不是什么好兆头。例如，当f1销毁时，资源会被释放，而f2则悬挂着，指向非法空间。</p>

<p>使用显性还是隐性转换，取决于具体的使用场景。一般来说，显性转换更好些，因为它能尽可能地减少在你不想转换时被转换的机会。</p>

<p>RAII类返回原资源是对封装的破坏，但可能并不是设计上的灾难。RAII类不是用来封装某些东西的。它们的存在是为了确保一个特定的行为（如资源释放）的发生。像大部分设计得好的类，它隐藏了用户不需要看到的部分，但也提供给用户对需要存取的数据的接口。</p>

<h3>Things to Remember</h3>

<ul>
<li>APIs经常要求原资源，所以每个RAII类都必须提供一个获取它管理的原资源的方法。</li>
<li>存取方法可以通过显性或者隐性的转换。一般来说，显性更安全些，但隐性对用户来说更加方便。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item14 认真考虑资源管理类的拷贝行为]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item14/"/>
    <updated>2014-10-28T20:01:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item14</id>
    <content type="html"><![CDATA[<p>有时，我们需要创建自己的资源管理类。
例如，你希望通过C API来操作锁对象的加锁和解锁功能。</p>

<blockquote><p>void lock(Mutex<em> pm);
void unlock(Mutex</em> pm);</p></blockquote>

<p>为了确保你不会忘记对已经加锁的对象解锁，你想创建一个类来管理锁。基本需求就是在该类的构造函数中加锁，在析构函数中解锁：</p>

<blockquote><pre><code>class Lock {
    public:
        explicit Lock(Mutex* pm): mutexPtr(pm)
        {
            lock(mutexPtr);
        }
        ~Lock() { unlock(mutexPtr); }
    private:
        Mutex* mutexPtr;
};
</code></pre></blockquote>

<p>用户使用RAII风格来使用Lock：</p>

<blockquote><pre><code>Mutex m;
{
    Lock ml(&amp;m);
    ...
}
</code></pre></blockquote>

<p>这运行得很好，但是当锁被拷贝时呢？</p>

<blockquote><pre><code>Lock ml1(&amp;m);
Lock ml2(ml1);
</code></pre></blockquote>

<p>这是类的编写者需要考虑的问题：当一个RAII对象被拷贝时，应该如何处理？大部分情况下，你会选用以下几个方式的一个来处理：
&ndash; 禁止拷贝。如果RAII对象拷贝没有意义时，你应该这么做。
&ndash; 记录资源引用数，当最后一个引用对象析构时才释放资源。</p>

<p>tr1::shared_ptr允许指定一个&#8221;deleter&#8221;&mdash;当引用数量为0时，调用指定函数或者函数对象。</p>

<blockquote><pre><code>class Lock{
public:
    explict Lock(Mutex* pm):mutexPtr(pm,unlock)
    {
        lock(mutexPtr.get());
    }
private:
    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;
};
</code></pre></blockquote>

<ul>
<li><p>对资源进行深拷贝。当你想拥有多个资源的拷贝，采用资源管理类只是为了确保每个资源都会被释放时，可以对管理的资源对象进行深拷贝。</p></li>
<li><p>移交控制权。如<em>auto_ptr</em>，拷贝方法（构造函数或者拷贝赋值操作）可能由编译器生成，如果这不是你想要的版本，你需要重写它们。</p></li>
</ul>


<h3>Things toRemember</h3>

<ul>
<li>资源的拷贝行为决定了RAII对象的拷贝行为</li>
<li>常见的RAII类拷贝行为为不允许拷贝和使用引用计数的方式，但也有一些其它的选择。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item13 使用对象来管理资源]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item13/"/>
    <updated>2014-10-28T19:35:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item13</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>有一个基类：</p>

<blockquote><p>class Investment {&hellip;};</p></blockquote>

<p>通过工厂函数来提供Investment实例：</p>

<blockquote><p>Investment* createInvestment();</p></blockquote>

<p>这样一来，createInvestment的调用者在使用完该函数提供的对象指针后，需要负责把它delete掉。</p>

<p>考虑以下的使用场景：</p>

<blockquote><pre><code>void f()
{
    Investment* pInv = createInvestment();
    ....  // some code
    delete pInv;
}
</code></pre></blockquote>

<p>以下场景会导致删除pInv失败：
&ndash; f函数在&hellip;中返回
&ndash; f函数在&hellip;中抛出异常</p>

<p>当然，细心地编程能够避免以上错误的发生。但代码在经过几次的修改后呢？在软件的维护过程中，有人可能会在中间添加新的return或者continue而没有很好地处理资源问题。更糟糕的是，在&hellip;部分以前可能没有使用异常机制，突然有人觉得应该加入以提高性能。简单地依赖于人员记得去删除资源是不可行的。</p>

<h3>解决方案一</h3>

<p>为了确定获得createInvestment返回的资源总能被释放，我们需要把资源放进一个对象中，该对象的析构函数总能自动地释放该资源。</p>

<p>很多用堆动态分配出来的资源，只用于一个特定的代码块中，当控制流离开代码块或者函数时，需要被释放。标准库的<em>auto_ptr</em>就是为这种场景量身定制的。<em>auto_ptr</em>是一个类指针对象，它的析构函数会自动删除它指向的资源。下面是如何使用<em>auto_ptr</em>来避免f函数潜在的内存泄露问题：</p>

<blockquote><pre><code>void f()
{
    std::auto_ptr&lt;Investment&gt; pInv(createInvestment());
...
}
</code></pre></blockquote>

<p>这个简单的例子展示了用对象来管理资源中两个关键概念：</p>

<p>资源总是在获取时立即放进资源管理对象中。上面例子中，资源中由<em>createInvestment()返回时，被用来初始化管理它的</em>auto_ptr*对象。这种方法叫做资源获得即初始化（RAII），因为在获得一个资源的同时，又初始化了资源管理的对象。有时资源是通过赋值传给资源管理对象。</p>

<p>由于<em>auto_ptr</em>对象析构时总会删除它指向的对象，很重要的一点就是需要保证不能有多于1个的<em>auto_ptr</em>指向同一个对象。不然，对象就会被删除超过一次。为了防止类似问题，<em>auto_ptr</em>有一个特性：对资源管理对象进行拷贝操作时，会把原来的管理对象设置为null的，也就是说，资源管理对象从原来对象转移到新的资源管理对象。</p>

<blockquote><pre><code>std::autoptr&lt;Investment&gt; pInv1(createInvestment());  //pInv1 points to the objct return from createInvestment
std::autoptr&lt;Investment&gt; pInv2(pInv1); //pInv2 now points to the object;pInv1 is now null
pInv2 = pInv2; //now pInv1 points to the object,and pInv2 is null
</code></pre></blockquote>

<p>这种拷贝特性意味着<em>auto_ptr</em>没法很好地管理所有的动态分配资源。例如STL容器要求它们的内容必须有正常的拷贝行为表现。</p>

<h3>解决方案二</h3>

<p>另外一个替换方案就是reference-counting smart pointer(RCSP)。然而<em>RSCP</em>无法处理循环引用 的问题（例如，两个没用的对象互相指向对方）。</p>

<p>TR1的tr1::shared_ptr就是一个RCSP。所以你可以这样写：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());
    ...
}
</code></pre></blockquote>

<p>代码看起来和使用<em>auto_ptr</em>一样，但拷贝<em>shared_ptr</em>的行为看起来自然一些：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv1(createInvestment()); //pInv1 points to the objct return from createInvestment
    std::tr1::shared_ptr&lt;Investment&gt; pInv2(pInv1);  //both pInv1 and pInv2 now point to the object
    pInv1 = pInv2;  // nothing changed
    ...
}
</code></pre></blockquote>

<p>由于<em>shraed_ptr</em>工作起来与STD容器所期望的一致，它能在STL容器中使用。</p>

<p><em>auto_ptr</em>和<em>tr1::shared_ptr</em>都在析构函数中使用了<em>delete</em>而不是<em>delete []</em>，这意味着无法使用它们来释放数组资源。</p>

<p>如果你想处理数组对象，你可以使用<em>boost::scoped_array</em>和<em>boost:shared_array</em>。</p>

<h3>Thigns to Remember</h3>

<ul>
<li>以防止资源泄露，在RAII对象构造函数中来获取资源，在它的析构函数中来释放资源。</li>
<li>两个有用的RAII类是TR1::shared_ptr和auto_ptr，通常来说，需要拷贝时，TR1::shared_ptr是更好的选择。拷贝auto_ptr会把原来的设置为null。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Doxygen生成文档]]></title>
    <link href="http://pliaohuimin.github.io/blog/20140909/use-doxygen/"/>
    <updated>2014-09-09T14:20:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20140909/use-doxygen</id>
    <content type="html"><![CDATA[<h4>在写代码时，使用doxygen vim插件生成特定格式的说明。</h4>

<h4>进入项目目录（test为例说明） cd test/</h4>

<h4>生成配置文件                          Doxygen –g</h4>

<p>note: 默认生成的配置文件名为 &ldquo;Doxyfile&#8221;，也可以采用 &#8220;doxygen -g your-cfg-filename&rdquo; 命令格式指定所生成的配置文件名。如无特殊需要，采用默认的配置文件名即可。</p>

<h4>配置文件的相应设置 ，这里已经有个模板Doxyfile(test文件夹下)，可以根据需要更改相应设置</h4>

<ul>
<li><p>项目名称，将作为于所生成的程序文档首页标题</p>

<blockquote><p>PROJECT_NAME           = Test</p></blockquote></li>
<li><p>文档版本号，可对应于项目版本号，譬如 svn、cvs 所生成的项目版本号</p>

<blockquote><p>PROJECT_NUMBER       = 1.0.0</p></blockquote></li>
<li><p>程序文档输出目录</p>

<blockquote><p>OUTPUT_DIRECTORY    =  doc/</p></blockquote></li>
<li><p>程序文档语言环境</p>

<blockquote><p>OUTPUT_LANGUAGE    = Chinese</p></blockquote></li>
<li><p>如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式</p>

<blockquote><p>OPTIMIZE_OUTPUT_FOR_C  = YES</p></blockquote></li>
<li><p>对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化</p>

<blockquote><p>TYPEDEF_HIDES_STRUCT   = YES</p></blockquote></li>
<li><p>在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YES</p>

<blockquote><p>HIDE_SCOPE_NAMES        = YES</p></blockquote></li>
<li><p>让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息</p>

<blockquote><p>QUIET   = YES</p></blockquote></li>
<li><p>只对头文件中的文档化信息生成程序文档</p>

<blockquote><p>FILE_PATTERNS          = *.h</p></blockquote></li>
<li><p>递归遍历当前目录的子目录，寻找被文档化的程序源文件</p>

<blockquote><p>RECURSIVE              = YES</p></blockquote></li>
<li><p>示例程序目录</p>

<blockquote><p>EXAMPLE_PATH           = example/</p></blockquote></li>
<li><p>示例程序的头文档 (.h 文件) 与实现文档 (.c 文件) 都作为程序文档化对象</p>

<blockquote><p>EXAMPLE_PATTERNS       = <em>.c </em>.h</p></blockquote></li>
<li><p>递归遍历示例程序目录的子目录，寻找被文档化的程序源文件</p>

<blockquote><p>EXAMPLE_RECURSIVE      = YES</p></blockquote></li>
<li><p>允许程序文档中显示本文档化的函数相互调用关系</p>

<blockquote><p>REFERENCED_BY_RELATION = YES
REFERENCES_RELATION    = YES
REFERENCES_LINK_SOURCE = YES</p></blockquote></li>
<li><p>不生成 latex 格式的程序文档</p>

<blockquote><p>GENERATE_LATEX         = NO</p></blockquote></li>
<li><p>在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包</p>

<blockquote><p>HAVE_DOT               = YES
CALL_GRAPH            = YES
CALLER_GRAPH        = YES</p></blockquote></li>
<li><p>让doxygen从配置文件所在的文件夹开始，递归地搜索所有的子目录及源文件</p>

<blockquote><p>RECURSIVE = YES</p></blockquote></li>
<li><p>在最后生成的文档中，把所有的源代码包含在其中</p>

<blockquote><p>SOURCE BROWSER = YES</p></blockquote></li>
<li><p>这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系</p>

<blockquote><p>GENERATE TREEVIEW ＝ ALL</p></blockquote></li>
</ul>


<h4>程序文档生成</h4>

<p>现在开始生成程序文档，将终端的工作目录定位在 test 目录，然后键入：</p>

<blockquote><p>$ doxygen    your-cfg-filename</p></blockquote>

<p>your-cfg-filename 是  Doxygen 配置文件名，如果是使用 &ldquo;doxygen -g&rdquo; 生成的配置文件——Doxyfile，那么可以在终端里仅键入 &ldquo;doxygen&rdquo; 命令即可生成程序文档。<br/>
生成的文档位于 test/doc/html 目录中，使用浏览器打开该目录中的 index.html 文件，即可看到自己的工作成果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014云南之旅--出发]]></title>
    <link href="http://pliaohuimin.github.io/blog/20140904/20140514-chufa/"/>
    <updated>2014-09-04T16:59:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20140904/20140514-chufa</id>
    <content type="html"><![CDATA[<h4>关于这趟旅行</h4>

<p>这完全是一次意外之旅。由于上层领导与股东的问题，公司在五月初宣布解散。在打包东西回住处的路上，同事问我有什么打算。突然心血来潮地决定出去旅游。刚好前阵子和还在说想自己出去走走，趁着回家休息，跟他提起想去云南旅游。三天的时间，决定一起出行。在网上定好机票，规划了整体路线，回广州办理一些工作上的手续就出发。</p>

<h4>必带物品</h4>

<p>防晒霜<br/>
保湿用品<br/>
防晒帽子<br/>
外套（昼夜温差大）<br/>
身份证<br/>
学生证（有的话）</p>

<h4>20140514</h4>

<p>早上回公司办理完手续，回去打包。在网上订的云南版LP刚好拿到手。这次旅行来得比较突然，没有做什么功课，全程就只靠这本书了。<br/>
下午五点五十分就从火车东站出发，六点半左右到达机场南站，到深航M窗口办理登机手续，队伍不是很长，十多分钟就办理完。不过这次电脑办不了托运，只能带着包登机，打火机过不了安检，洗发水居然没事。七点十来分到达登记窗口却被告知飞机晚点，九点二十分才登机，汗。登记后，又继续在飞机上发霉，十点出头才真正起飞 。<br/>
十二点左右才到达昆明长水机场。比较顺利地搭上了的，打表96元到达中凰酒店附近舍友的住处。一切打点完毕，已是凌晨两点。明天去东川，得早起，OMG。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[添加博客头像]]></title>
    <link href="http://pliaohuimin.github.io/blog/20140811/add-profilepic/"/>
    <updated>2014-08-11T15:57:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20140811/add-profilepic</id>
    <content type="html"><![CDATA[<p>新安装了<a href="https://github.com/shashankmehta/greyshade">greyshade</a>主题。</p>

<p>好奇于其他使用这个主题的其它博客，有头像的展示。一直找不到在哪设置。
原来还有<a href="http://en.gravatar.com/">gravatar</a>这种东西，通过邮箱来显示头像。只要设置好邮箱，并在gravatar服务上注册相应邮箱，上传头像就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[申请了新域名]]></title>
    <link href="http://pliaohuimin.github.io/blog/20140808/new-domain/"/>
    <updated>2014-08-08T14:01:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20140808/new-domain</id>
    <content type="html"><![CDATA[<p>今天下定决心买了域名：<a href="http://www.minlh.com/">http://www.minlh.com/</a></p>

<p>之前用的是.tk免费域名，但总觉得打开页面很卡，不知道跟域名是否有关,还是使用github的原因。
可是打开github时也不觉得特别卡，考虑一下，觉得还是买个.com的域名比较靠谱些，反正也不算太贵。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在新机器上使用octopress写文章]]></title>
    <link href="http://pliaohuimin.github.io/blog/20140805/new-machine-to-octopress/"/>
    <updated>2014-08-05T18:57:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20140805/new-machine-to-octopress</id>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html">主要参考来源</a></p>

<ol>
<li><p>安装git</p></li>
<li><p>从github上面克隆代码到本机特定目录。</p>

<blockquote><p>git clone -b source git@github.com:pliaohuimin/pliaohuimin.github.com.git</p></blockquote></li>
<li><p>安装<a href="http://rubyinstaller.org/downloads/">RUBY</a> 1.9.3。记得勾选“Add Ruby executables to your PATH”，将Ruby的执行路径加入到环境变量中，如果忘记勾选，也可以手动设置</p></li>
<li><p>安装<a href="http://cloud.github.com/downloads/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe">DevKit</a>，将其解压到D:/DevKit，有两点需要注意：</p>

<p>  解压目录中没有有中文和空格；</p>

<p>  必须先安装Ruby，而且Ruby需要是RubyInstallser安装。</p>

<p>  解压DevKit后，在命令行输入以下命令来进行安装：</p>

<blockquote><p>d:</p>

<p>cd DevKit</p>

<p>ruby dk.rb init</p>

<p>ruby dk.rb install</p></blockquote></li>
<li><p>安装Python</p></li>
<li><p>安装<a href="https://pypi.python.org/pypi/setuptools">easy_install</a>,</p>

<p> For Windows 7 and earlier, download ez_setup.py using your favorite web browser or other technique and &ldquo;run&rdquo; that file.</p></li>
<li><p>安装pygments</p>

<p> easy_install会安装在Python安装目录的Scripts目录中，例如我的Python目录是C:\Python27，所以需要将C:\Python27\Scripts目录加入到环境变量中才能在命令提示符中使用easy_install命令。</p>

<p> 在命令提示符中输入如下命令就可以安装Pygments了。</p>

<blockquote><p>easy_install pygments</p></blockquote></li>
<li><p>然后需要安装Octopress的依赖项，安装依赖项需要用到Ruby的gem，使用下面的命令可以更换gem的更新源，使用国内的淘宝镜像速度相对快点。</p>

<blockquote><p>gem sources -a <a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a></p>

<p>gem sources -r <a href="http://rubygems.org/">http://rubygems.org/</a></p>

<p>gem sources -l</p></blockquote>

<p> 修改Octopress目录下的Gemfile文件，将第一行的<a href="http://rubygems.org/">http://rubygems.org/</a> 修改为<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a></p>

<p> 在命令提示符中进入到Octopress目录，输入下面命令进行依赖项的安装</p>

<blockquote><p>gem install bundler</p>

<p>bundle install</p></blockquote></li>
<li><p>在Octopress中添加文章
 使用下面命令可以在Octopress中添加文章</p>

<blockquote><p>rake new_post[&lsquo;post name&rsquo;]</p></blockquote>

<p> 注意，rake new_post[&lsquo;my first octopress blog&rsquo;]中的my first octopress blog 并不是博客标题，而是和生成的文件名以及url地址有关，该名称不支持中文。博客标题可以在生成的markdown文件中修改。生成的markdown文件在octopress/source/_posts目录中。</p>

<p> 编辑markdown文件，将标题可以修改为中文标题，还可以设置分类等信息以及编写正文部分</p>

<p> 每次执行了添加博客的命令，或是修改了现有博客的内容后，都要执行下面命令进行重新生成静态网页</p>

<blockquote><p>rake generate</p></blockquote></li>
<li><p>发布到外网
创建<em>deploy目录,将上一层的.git目录拷贝到</em>deploy下。将主干checkout出来。只需要操作一下，以后可以直接部署。</p>

<blockquote><p>git checkout master</p></blockquote>

下面指令帮你把生成的静态网页更新到主干master上去。

<blockquote><p>rake deploy</p></blockquote></li>
</ol>


<p>done
输入rake preview，可以直接localhost:4000来进行预览</p>

<h2>问题：</h2>

<p>1.执行rake generate时，报错
YAML Exception reading 2012-07-21-8.textile: invalid byte sequence in GBK
YAML Exception reading 2012-07-22-13.textile: invalid byte sequence in GBK
YAML Exception reading 2012-07-23-20.textile: invalid byte sequence in GBK
YAML Exception reading 2012-07-28-35.textile: invalid byte sequence in GBK</p>

<p><a href="http://changfengmingzhi.blog.163.com/blog/static/16710528820131013103511364/">1解决方法</a>：
找到你的Ruby安装目录，如我的是：D:\Ruby193, 在里面找到文件D:\Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-0.12.0\lib\jekyll\convertible.rb
在该文件中找到下面句子：</p>

<blockquote><p>   def read_yaml(base, name)</p>

<pre><code> self.content = File.read(File.join(base, name))
</code></pre></blockquote>

<p>将它修改为：</p>

<blockquote><p>   def read_yaml(base, name)</p>

<pre><code> self.content = File.read(File.join(base, name),:encoding=&gt;"utf-8")
</code></pre></blockquote>

<p>然后确保所有带中文字符的markdown文件是无BOM的UTF-8格式即可。</p>

<p>2.解决问题1后，执行rake generate时，继续报错
Liquid Exception: incompatible character encodings: UTF-8 and GBK in index.html</p>

<p>将</p>

<pre><code>&gt;export LC_ALL=zh_CN.UTF-8 
&gt;export LANG=zh_CN.UTF-8
</code></pre>

<p>放到~/.bash_profile中，并执行：</p>

<pre><code>&gt;source ~/.bash_profile
</code></pre>

<p>在cmd窗口执行，chcp 65001
然后继续在cmd窗口执行(不可以在bash窗口执行，估计只对当前窗口有效,而bash窗口又无法执行chcp命令）：</p>

<pre><code>&gt;rake generate
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress小工具]]></title>
    <link href="http://pliaohuimin.github.io/blog/20130902/add-share/"/>
    <updated>2013-09-02T21:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20130902/add-share</id>
    <content type="html"><![CDATA[<h3>添加一键共享</h3>

<p>我目前使用的是bshare。<br/>
在<em>config.yml中增加bshare: true。在“source/</em>includes/post”下的sharing.html中增加如下代码：</p>

<pre><code>&lt;a class="bshareDiv" href="http://www.bshare.cn/share"&gt;Sharing&lt;/a&gt;&lt;script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#uuid=25fcdf85-62f9-400e-b053-627f102edf5a&amp;style=999&amp;img=http%3A%2F%2Fstatic.bshare.cn%2Fimages%2Fbuttons%2Fbox-shareTo-zh.gif&amp;w=147&amp;h=21"&gt;&lt;/script&gt;
</code></pre>

<p>上述的代码由bshare产生，可以自己选择所需的外观。这样，在每一篇文章的最下方会出现一个分享的小工具。</p>

<h3>添加DISQUC评论</h3>

<p>首先需要在Disqus注册一个账号，登录后添加站点信息，将填写的short_name写到<em>config.yml中，并将</em>config.yml中的disqus_show_comment_count设置为true.如下：</p>

<pre><code># Disqus Comments
disqus_short_name: liao   # liao为添加站点信息时的Site Shortname
disqus_show_comment_count: true
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[赞一个OCTOPRESS的ARCHIVE展示]]></title>
    <link href="http://pliaohuimin.github.io/blog/20130902/octopress-archive/"/>
    <updated>2013-09-02T16:05:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20130902/octopress-archive</id>
    <content type="html"><![CDATA[<p>感觉挺好的，对于之前发布过的文章，简洁，一目了然。<br/>
之前还在琢磨着要不要给这些文章分目录，现在看来要重新考虑一下分目录的必要性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从wordpress迁移到octopress]]></title>
    <link href="http://pliaohuimin.github.io/blog/20130901/from-wp2octopress/"/>
    <updated>2013-09-01T03:54:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20130901/from-wp2octopress</id>
    <content type="html"><![CDATA[<h2>为什么要迁移：</h2>

<blockquote><p>并不是觉得wordpress不好用，而是由于之前一直在使用的noads.biz服务器开始在我的个人网站上放广告，而我找不到其它更好的劫持php,mysql的免费服务器，所以决定使用octopress，可以直接把内容放在github上。</p></blockquote>

<h2>迁移步骤：</h2>

<h3>准备工作</h3>

<ul>
<li>step 1:在github上注册一个用户。并用该用户创建一个“username.github.com“的项目库，其中username为你在github注册的用户</li>
<li>step 2:在LINUX上安装好GIT</li>
<li>step 3:在LINUX上安装好ruby
curl -L <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable &mdash;ruby
source /home/liao/.rvm/scripts/rvm
如果执行下列命令报错，请重新打开终端，并再次执行source /home/liao/.rvm/scripts/rvm</li>
</ul>


<h3>安装好OCTOPRESS</h3>

<ul>
<li>step 4:克隆octopress项目
git clone git://github.com/imathis/octopress.git</li>
<li>step 5:安装OCTOPRESS
gem install bundler
bundle install</li>
<li>step 6:安装主题
rake install</li>
</ul>


<h3>部署到GITHUB</h3>

<ul>
<li>step 7:rake setup_github_pages
期间会要求你输入项目地址，请输入:git@github.com:username.github.com
期中username为你在github的用户名。</li>
<li>step 8:生成代码
rake generate</li>
<li>step 9:部署到github上
rake deploy
期间可能会报错，可以尝试跳转到_deploy目录下，运行git pull origin master。再回到上一层再次执行rake deploy</li>
<li>step 10:备份相关文件到source分支
git add
git commit -m &lsquo;your message
git push origin source
如果报错，可以尝试先执行下列命令，再一次执行上面的命令。
git branch source
git checkout source</li>
</ul>


<h3>关于域名的绑定</h3>

<p>如果是使用一级域名，在source目录下添加CNAME文件，并在里面添加你的域名，如www.minlh.tk<br/>
然后在你的域名服务商那里添加一行A RECORD，IP地址为207.97.227.245</p>

<h3>关于文章的迁移</h3>

<p>使用wordpress后台管理工具，将数据导出成xml格式
安装必要工具：
gem install hpricot
gem install ya2yaml
使用XDITE提供的工具
<a href="https://gist.github.com/xdite/1273518">https://gist.github.com/xdite/1273518</a></p>

<p>执行直接執行 ruby xxx.rb xxx.xml 名
st目录，将该目录下的所有文件拷贝到source/_post目录下即可。</p>

<h3>关于文章中图片的迁移</h3>

<p>将wp-content/uploads目录下载，上传到source目录即可。
图片链接出现时border=0 hspace=0 alt=&ldquo;&rdquo; align=baseline，会导致生成的blogs双引号自动转换成&#8220;字样，需要将这些去掉，图片才能正常显示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始OCTOPRESS]]></title>
    <link href="http://pliaohuimin.github.io/blog/20130830/kai-shi-octopress/"/>
    <updated>2013-08-30T17:28:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20130830/kai-shi-octopress</id>
    <content type="html"><![CDATA[<p><a href="http://www.flickr.com/photos/minlh/9631485119/" title="hua by liaosihao, on Flickr"><img src="http://farm4.staticflickr.com/3721/9631485119_3edb45c7c5.jpg" width="377" height="500" alt="hua"></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识REDIS]]></title>
    <link href="http://pliaohuimin.github.io/blogs/583"/>
    <updated>2013-08-20T00:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blogs/583</id>
    <content type="html"><![CDATA[<div>上一个游戏项目使用了MEMCACHED作缓存和MYSQL作持久化的数据结构。</div><div>早在上个项目后期，主线就一直想把MEMCACHED替换成REDIS，至于是出于什么样子的考虑，由于个人层次原因，不是很明白。后来由于时间的关系，这件事情也就不了了之了。</div><div>到了这个项目，新的游戏也接近上线，主程还是对这个REDIS念念不忘。这个替换的任务落到了我头上，也刚好让我对REDIS有点皮毛的认识。下面先说说为什么要替换掉MEMCACHED：</div><div>首先，REDIS提供多种数据结构，大部份与STL接口，如SET，STRING，LIST等。这次项目的使用到的HASH结构。&nbsp;&nbsp;&nbsp;</div><div>使用这种结构，可以解决上个项目中，对于每个玩家只有一行记录的表，无法一次性整表读取的问题。使用REDIS 的HASH结构，将数据库名称与表名作为KEY，玩家唯一标识字段设定为FIELD，再将玩家数据作为VALUE存入。通过HVALS即可获取整表记录。</div><div>另外，之前使用MEMCACHED，还得自己维护多一个元数据在缓存中，以使业务获取KEY的信息。而通过REDIS的HASH，简单的HVALS即可达到目的。</div><div>以上就是本人对REDIS皮毛上的认识。本质上更多的区别，还有待深入了解。</div><div>再说说这几天使用的情况：</div><div>此次服务器版本使用的是v2.6。客户端API采用了HIREDIS的C接口。之前有考虑使用C++接口，给主程否了，说不稳定。作为小白，只有乖乖听话，改用HIREDIS。</div><div>起初的版本比较简单，&nbsp;&nbsp;没有考虑到连接REDIS服务器失败后，后续接口的异常情况。在经过无数次DUMP机之后，发现罪魁祸首就是由于连接服务器失败，redisContext中的o_buf并没有初始化，而在执行redisCommand时，需要用到o_buf，导致内存越界。后来将redisCommand进行封装，每次执行里先检查redisContext指针。问题算是解决了，然后，引入了新的问题。</div><div>对redisCommand进行封装时，使用了va_list来处理变长参数，又直接使用redisCommand来执行，还是DUMP机，看了源代码，发现用错函数了，应该使用redisvCommand，替换后，终于不当机了。</div><div>接着是处理各种断连情况。</div><div>第一种情况是，程序启动时，REDIS服务没有启动，这时连接失败。那么在以后每次执行指令时，对于redisContext指针为空的情况，需要加入重连机制，保证当REDIS服务启动后，程序主动进行连接，避免程序需要重启，REDIS机制才会生效的问题。</div><div>第二种情况是，程序启动时，REDIS服务也启动。但是在运行过程中，REDIS服务关闭了。这时，程序也需要对REDIS服务提供重连机制，同样是为了避免一旦REDIS服务器关闭后再启动，也无法使用的问题。</div><div>经测试，处于第二种情况时，REDIS服务关闭后，连接断开。执行redisCommand会返回空指针，由于，程序在每次执行完后，都会对指针进行判断，一旦为空，就会尝试重连。</div><div>在实际测试中，发现REDIS默认有持久化的机制，基于这个项目，并不需要持久化机制，除了增加开销，还是导致数据异常。尝试将配置文件的save配置都注释了，发现还是会有持久会。如何关闭，还有待观察。</div><div>另外一个问题就是，玩家在线，将REDIS服务器关了再重启，这时REDIS缓存为空。之后如果玩家作了某些操作，在从数据库加载数据到缓存前，触发了HSET操作，会导致之后都不会从数据库中加载数据，同样会造成数据异常。解决方法是，在每次SET之前，都会查询当前缓存中，有没有相应KEY的信息，如果没有，先从数据库加载后再执行SET操作。</div><p><br /><br /><div><a title="来自为知笔记(Wiz)" href="http://www.wiz.cn/i/f962040b">来自为知笔记(Wiz)</a></div><br /><br /></p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013年8月17日 1:24:24     晴]]></title>
    <link href="http://pliaohuimin.github.io/blogs/579"/>
    <updated>2013-08-16T00:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blogs/579</id>
    <content type="html"><![CDATA[<div>今天一觉醒来，已经是九点多。非常不喜欢这种感觉，可这种事情总会时不时地蹦出来，吓你一跳。还好没造成多大的不好影响。去到公司刚好大家在开例会，跟大家道了个歉。</div><div>下班的时候，听同事说起他明天要去西冲玩。突然想起去年五一我们三人去徒步的事情。不知道为什么，明明只是去年的事情，想起来，感觉怎么那么遥远。</div><p><br /><br /><div><a title="来自为知笔记(Wiz)" href="http://www.wiz.cn/i/f962040b">来自为知笔记(Wiz)</a></div><br /><br /></p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[素可泰]]></title>
    <link href="http://pliaohuimin.github.io/blogs/574"/>
    <updated>2013-07-03T00:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blogs/574</id>
    <content type="html"><![CDATA[<div>2013/04/07</div><div>此班次的车终点并不是素可泰，一路上不敢熟睡。汽车开开停停，在凌晨四点多，抵达素可泰新城不远处的车站。大半夜的，车站只有几个零散的工作人员和敬业的TUTU车司机。心想，就算打车去到新城，这么晚也不好找住的，大半夜入住还得付多一天的房费，不划算，不如索性在这里呆到五六点，天亮了再慢慢走过去。打开随身携带的KINDLE，看看书，做做功课，一两个钟的时间其实也不是很难熬。出来久了，发现自己也慢慢地淡定多了。天色开始亮起来，一个人慢悠悠地在上走着，走了大半个钟才来到新城。清晨的街道，行人很少，看着太阳一点一点地往上冒，心想着，这就是行者的生活。</div><div><img  src="http://www.minlh.tk/uploads/2013/07/wpid-2e1127b1da8f126a1ff882b0778b8aa6_bf81947f9a3a71970c687a87ea1369b0.png"></div><div>原来攻略上说的100BAHT的单人房已经找不着了，至少都要150，挑了一个环境还可以入住。老板有点意思，第一次问他房价时，他说最低150，当他知道我要找100BAHT的房子时，很热心地介绍另一家客栈给我。只可惜那一家也涨价了。所以又折回头去CHECK IN。</div><div>白天的素可泰也是阳光普照。冲凉，补觉，中午出去吃了个午饭又回来避暑。下午4，5点时，才跑出去租了辆单车去旧城探探路。30BAHT租来的单车很破，老板还强调不能骑去旧城，我满口答应着，回头就直奔旧城。在旧城物色好明天要入住的客栈，可惜已经住满，只能明天再来碰碰运气。回途中，经过BIG C，买了一个很奇怪的水果，外表有点像青苹果，里面其实是番石榴。</div><div><img  src="http://www.minlh.tk/uploads/2013/07/wpid-2e1127b1da8f126a1ff882b0778b8aa6_15298df427fcef8f3478af76560b782a.png"></div><div>&nbsp;</div><div>逛了逛新城的市场，又采购了20BAHT的红毛丹，回去一数，好样的居然有二三十个。</div><div>&nbsp;</div><div>&nbsp;</div><div>2013/04/08</div><div>担心昨天看好的客栈房子被租满了，起了个“早床”坐着双条车直奔古城。刚好有一空房，果断CHECK IN。租了辆单车，开始逛公园。建筑跟吴哥窟是没得比，印象比较深的就是那些佛的各种姿态。公园不大，骑着单车很快就逛完了。回客栈休息。在外面看《我是歌手》的时候，进来了一个女孩，皮肤很黑，不料居然是个中国人。聊了会天，她明天也打算去清迈，约好了一起搭车过去。今天的阳光很晒，一直在屋里躲到5点左右才敢出去逛。又骑着单车朝公园外围转了一圈。没什么特殊的景点，人很少，整个环境感觉很安静，就一个人，吹着风，迎着夕阳，随意地走在路上，感觉还是很自在的。</div><p><br /><br /><div><a title="来自为知笔记(Wiz)" href="http://www.wiz.cn/i/f962040b">来自为知笔记(Wiz)</a></div><br /><br /></p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[曼谷北站的等车生活]]></title>
    <link href="http://pliaohuimin.github.io/blogs/570"/>
    <updated>2013-06-02T00:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blogs/570</id>
    <content type="html"><![CDATA[<div>计划中的早起，明显已经落空了。起来时已经九点多。从河边的住处稍稍向外走，看到有一摊卖小吃的早餐档，当时点了什么，现在已经记不起来，印象中跟中国的小吃有点接近，味道嘛，不难吃，但也不是特别美味，很大众的口味。昨天在网上查到，不远处的河边，就是一个邮局。虽然这个河边小镇的水上市场跟我心目中的有点落差，但是在这里呆上几天，特别是非周末的时候，应该也是个不错的选择。这也是让我有冲动要去寄张明信片的原因。无奈，虽然邮局的门口写着今天是有营业的，可是已经到了营业时间，却依然大门紧锁。跟我一起在门口等的还是一对本地父女，看样子是想寄东西，我稍等片刻后觉得没什么希望，转身走人，当我走在路上的时候，那父女也从后面跟上来，跟我说了声再见，也离开了。</div><p><!--more--><div>回到客栈，APPLE和GRACE已经在打包东西，准备回曼谷，问我是不是要一起回去，她们已经跟老板打听好回去坐车的位置。最后，我们坐着十一点钟的MINI VAN，又回到了曼谷。车子依旧停在胜利纪念碑处，她们两个要去火车站那边坐汽车去清迈，我呢，刚想着先去素可泰看看。</div><div>在曼谷北站，MOCHIT汽车站有去素可泰的汽车。可是很悲催的是，我提前下车了，又得重新坐公共汽车去车站，本来想着打的的，可是又怕被坑，还是老老实实地坐公车。从汽车的终点站下车，穿过一个小市场，终于看到7-11，急忙把肚子先填饱先。在走错了无数个窗口之后，我终于来到卖去素可泰车票的窗口。说起买票，最麻烦的就是地名的发音，每次都发不准，搞得沟通起来很麻烦，后面才从卖票员的口中得到正确的发音。素可泰的发音有点类似于“濑口抬（第一声，有点像抬的潮汕发音）&quot;。到达车站的时候已经是大约两点，只有4点以后的车票了，想着4点的车到那边，差不多是晚上十点，太晚了，不如直接买最晚的一班车，到那里刚好是清晨，结果最晚的只有10的汽车，到那里是第二天早上的4点多。纠结了一会之后，决定买晚上10点的车票，至少可以省上一晚的住宿费。于是，长达8小时的等车生活开始了。只能无聊地拿着KINDLE看看书，偶尔去7-11买点小吃。中间还想着搭车再去CENTRAL WORLD逛逛，可走到公车站后，又觉得坐着来回3个小时的汽车，然后去那里逛一两个小时，太不划算了，又折回车站继续等。</div><div>傍晚6点的时候，我正在痛苦地吃着刚刚买的酸臭味的米线，突然音乐响起，一抬头，周围的人通通都站着不动，也就我和极少数的人坐着，其他的人都站了起来。弄得我不知道是该站还是该坐，只好一动不动地坐在那里。过完片刻，音乐停了，大家又继续活动。据说，<span>在每天早晚上下班高峰时，泰国国歌会在各街道、公园、公共场所奏起，所有泰国人都会停下手里的事情，赶路的不再赶路，聊天的不再谈笑，打电话的立即挂机，甚至连吵架的都会暂停，大家一致肃立，面容严肃，仔细聆听国歌，跟着颂唱，直至结束才继续做事情。这一幕每天准时都会发生两次，分别是早上8时和晚上6时。真是个有趣的国家。</span></div><div><span>大约离上车时间还有半个小时的时候，我就开始弄清楚具体的上车站点，再次跟工作人员确定好上车时间。<span>回想起来，这好像是我第一次不通过旅游公司的汽车，自己到车站买票搭车。心里还是有点没底，生怕错过班车。因为素可泰只是一个过路的站点，所以汽车上没有写着从BANGKOK到<span>Sukhothai，又是再三地询问，才弄清楚要上哪一部车。这次搭车，给我感觉曼谷的汽车站管理，不是很规范。来泰国之前，听到说，泰国到处都是英语，亲自来到曼谷的时候，才知道这句话有多坑人。</span></span></span></div><div><span><span><span>总算是上车了，想起一大早就要下车，心里还是有点不爽。还不能熟睡，万一睡过头了，那将会是很悲催的一件事。</span></span></span></div><br /><br /><div><a title="来自为知笔记(Wiz)" href="http://www.wiz.cn/i/f962040b">来自为知笔记(Wiz)</a></div><br /><br /></p>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[美功铁道市场和安帕瓦]]></title>
    <link href="http://pliaohuimin.github.io/blogs/568"/>
    <updated>2013-04-26T00:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blogs/568</id>
    <content type="html"><![CDATA[
		<ol>
			<li>2013/04/05<div>不想在曼谷呆了，确实不喜欢这个城市，标准的大城市，没什么好玩的，出门就得搭车，还塞车，消费高天气又热。我决定去水上市场看看。听说离这里两个小时车程的安帕瓦水上市场比较原始，而且附近有最近网上流传的美功铁道市场，也可以顺道见识一下。</div><div>今天算是比较早起，打算先去CENTRAL WORLD买双鞋子。结果证明，早起不一定是好事，去到那里才发现所以购物中心都是十点才开门，背着大行李包在周围晃悠了一个来小时才能进去。狠下心买了双840BAHT的拖鞋，搭着公车来到胜利纪念碑坐MINI VAN去美功。车站的位置有点难找，不过路在口下，多问几下就行了。汽车的终点站就是安帕瓦，80BAHT。不过我想先去美功市场看看，所以只买到美功，70BAHT。因为早上买鞋的时候商店没开，浪费了一些时间，已经来不及看12点半那趟火车经过的场景。一点多到达美功后，了解到最快的一班火车是3点进站。也好，调整一下，顺便吃个午餐。原来以为火车在这里只是过路，来到这里才发现，过了市场不远处就是火车的终点站了，所以火车经过市场的速度是相当的慢。这个也可以理解，如果速度很快的话，那么在这里买卖东西的人还真会有生命危险，毕竟每天都要经历好几次火车经过的过程。值得一提的是，来这里看火车的，百分之八十都是中国人，中间还看到两个中国旅行团过来。东南亚，真心不缺中国人。</div><!--more--><div>看完火车，搭着双条车去安帕瓦水上市场，两者相距有一段距离，好在车费便宜，8BAHT每人。来安帕瓦的人，大部分当天从曼谷过来，当天晚上就离开回曼谷。像我这种打算在这里住一个晚上的很少。还好，在坐双条车的时候，旁边两个女孩子也背着行李包出来，一看就知道今晚是在这里呆着的。交流了一下，约好下车后一起去找住的地方。</div><div>从下车地点往旁边小路进去没多远，就可以在右手边看到架在安帕瓦河流之上的石桥。一路走过来也没有看到什么客栈，最后在河边找到一家，开价空调间900BAHT，对于我这种屌丝肯定是住不起的啦，两个台湾女生决定住下，帮我砍价砍到400BAHT风扇房，还是觉得小贵，但是出去转了一下，只找一个300BAHT的，环境比这里差很多，最后还是决定住下。这也是这一路走下来住过最贵的一晚。</div><div><span class="caps">CHECK</span> IN，收拾好心情，沿着岸边走，在河边的船上买了一些海鲜充当晚餐。虽然今天已经是周五，水上市场只有周五，六日才有。但是整体看来，河面上卖东西的商船并不多，游客也少。所以没什么看头。不过刚从繁忙的曼谷突然来到宁静的河边小镇，感觉还是挺安逸的。晚上8点左右的时候，坐上了去看萤火虫的船，每个人60BAHT，可以看河边的萤火虫。原本以为会有大量的萤火虫出现，把周围照亮。事实证明，如果你视力不好或者不够细心，那是很有可能什么都看不到。所谓的萤火虫就是偶尔在某颗树上隐隐约约发现的微光，不留意还真难发现。60BAHT坐着船在河上走一个小时，还是划得来的，就是声音吵了点，而关于萤火虫，我只能说这是“标题党”的行为。</div><div>总体来说，喜欢宁静的人，挑个非周末的时间，来这里呆上几天，也是挺好的一个选择。虽然没去过乌镇，但这里就是我想象中乌镇的形象。</div><div>&nbsp;</div><div>&nbsp;</div><br /><br /><div><a title="来自为知笔记(Wiz)" href="http://www.wiz.cn/i/f962040b">来自为知笔记(Wiz)</a></div><br /><br /></li>
		</ol>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[曼谷逛街]]></title>
    <link href="http://pliaohuimin.github.io/blogs/566"/>
    <updated>2013-04-21T00:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blogs/566</id>
    <content type="html"><![CDATA[
		<ol>
			<li>2013/04/04<div>早上起来根据昨晚在游记上看到的推荐，在考山路东面的BURGER KING旁边巷子里找到一天140BAHT的单间。环境是差了一点，不过也不怎么在里面呆，考虑在钱的份上，忍了。</div><div>今天纯粹是为了逛街而逛街。我决定尝试坐公车去CENTRAL WORLD。根据网上的信息，我可以做2号公车过去。可是问了一妹子，本来只是想问方向对不对，谁知道她告诉我只能做811路。好吧，听你的。好不容易等来公车，还是空调的，其实我是想做非空调的。空调的要17BAHT，非空调的估计只是7BAHT。折算过来，在曼谷坐公车也不便宜，空调车要接近4块钱RMB。曼谷的公车没报站，站台上也没有写站名，所以在哪下车，你只能靠猜了，或者指望售票员能友善地提醒。看着汽车停了一站又一站，心里完全没底，还好，旁边一泰国人看我手拿着KINDLE东张西望的，问我是不是中国人，原来他是泰籍华裔，有说普通话。他告诉我这辆车没经过CENTRAL WORLD（我猜是快线车吧），只经过水门市场，在那下之后，向前走，在天桥下右转就到了CENTRAL WORLD。谢天谢地，还好碰到好心人，要不要都不知道会搭到哪去。</div><!--more--><div>还以为曼谷的东西会很便宜，实际上并没有，LEVIS，LEE的牛仔裤也要1800起，也就是400块钱左右，便宜不了多少，优衣库，ZARA感觉比中国的还贵。在逛了CENTRAL WORLD， <span class="caps">BIG</span> C之后，我已经没有购物的愿望了。</div><div>中午在SIAM PARAGON吃了午饭，看到DQ很便宜，一个冰淇淋才39BAHT，十块钱不到，试了一下，其实味道也一般。经过一摊卖奶茶的，看做奶茶的过程中还有拉茶，挺牛逼的样子，想着回头再来买，不过后来忘记买了，没能喝上。吃完又是逛，在H&amp;M看到一件440BAHT的长袖衬衫，决定下手。来到顶楼的电影院，还没在国外看过电影，想试一下听英语看泰文的电影是什么滋味。问了费用，150BAHT，还行。结果，沟通不好，她给我一张500BAHT，好像是150BAHT那一场还要等很久都能看。花一百多RMB在国外看一部看不懂的电影，太奢侈了，还好能退票。退票后，我跟售票员说了一声SORRY，她居然也跟我说SORRY，今时今日就应该这种服务态度。</div><div>走累了，想试着坐船回去，顺便看看郑王庙，听说傍晚时分过去看看还不错。去到码头才知道河道不同，没有船到大皇宫附近。只能折回去坐公车，回去时已经太晚了，没去成。</div><div>在考山路找吃的时候，看到前面一个人的眼镜掉了，好心捡起来还给他，谁知道他转身的时候脚踏到我的鞋了，我的脚一抬，拖鞋宣布报销。今天在逛CROCS的时候还要考虑买双拖鞋呢，大概200块钱的拖鞋是贵了点，没敢下手。这样可好，要路边问了一家卖拖鞋的，一双要250BAHT，大约50块钱，算了，还是明天狠下心买双CROCS的吧，反正没穿过，试一下是不是物有所值。</div><br /><br /><div><a title="来自为知笔记(Wiz)" href="http://www.wiz.cn/i/f962040b">来自为知笔记(Wiz)</a></div><br /><br /></li>
		</ol>]]></content>
  </entry>
  
</feed>
