---
layout: post
title: '正确使用#include和前置声明(forward declaration)'
date: 2012-8-11
wordpress_id: 69
permalink: /blogs/69
comments: true
---
<p>转自网站：<a href="http://blog.csdn.net/SpriteLW/article/details/965702">http://blog.csdn.net/SpriteLW/article/details/965702</a></p> <p>差不多一年时间没用过C++写过程序了,由于工作的需要,我又回到了C++的阵形。在工作的过程中遇到了很多麻烦，当我往工程里加一个类，而且那个类又与工程里的类相关，如有那个类型的成员变量。情况如下 <p>//////A.h/////////// <p>class A <p>{ <p>....... <p>}; <p>////////B.h////////// <p>class B:A <p>{ <p>.... <p>A member; <p>} <p>结果，编译就会出错，说找不到类形A。解决的办法是在B.h里#include “A.h”。但是有时候不用#include “A.h”，只要在classB:A前加class A;就可以了。更严重的是不但要#include “A.h”，还要class A;。 <p>起初觉得没问题，因为这样搞来搞去总会编译通过的，而且不会让程序变大，因为有#ifndef...#endif和#pragma once控制。直到有一次，我需要那些常量放到一个文件中“const.h”，然后include到其它需要它的类中，结果怎么也编译不成功（因为文件多了，而且每个文件都这样互相include，把我也蒙了） <p>直到今天终于从《Effective C++》里找到原理。现向大家分享一下，首先我以下面这个类结构作例子。（先不管我为什么不加一个Woman，为什么Man就有child，我只是作例子解说，绝没有性别歧视。 <p><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/SpriteLW/gif_1.gif"> <p>代码如下： <p>////////////main.h////////////// <p>#include "stdafx.h" <p>#include "man.h" <p>int main(){ <p>&nbsp;&nbsp;&nbsp; Man m; <p>return 0; <p>} <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>}; <p>////////Person.cpp/////////// <p>#include "StdAfx.h" <p>#include "./person.h" <p>Person::Person(void){ <p>} <p>Person::~Person(void){ <p>} <p>/////////Man.h/////////// <p>#pragma once <p>#include "person.h" <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////////Man.cpp////////////// <p>#include "StdAfx.h" <p>#include "./man.h" <p>Man::Man(void){ <p>} <p>Man::~Man(void){ <p>} <p>上述代码，编译运行一切正常。现在我作以下修改： <p>/////////Man.h/////////// <p>#pragma once <p>//#include "person.h"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉 <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include "person.h"&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>error C2504: “Person” : 未定义基类 <p>error C2504: “Person” : 未定义基类 <p>/////////Man.h/////////// <p>#pragma once <p>//#include "person.h"&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include "person.h"&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>error C2504: “Person” : 未定义基类 <p>编译通过 <p>要讲解上面的代码还要一些预备知备，看下面代码： <p>int main() <p>{ <p>int x; <p>&nbsp;&nbsp;&nbsp; Person p;//用C++时编译不通过; <p>} <p>当编译器看到x定义式时，它们知道必须配置足够的空间以放置一个int。没问题，每个编译器都知道int有多大。然而当编译器看到p的定义式时，虽然它们也知道必须配置足够空间以放置一个Person，但一个Person对象有多大呢？编译器获得这项信息的唯一办法就是询问class定义式。然而class的定义式可以合法地不列出实现细节（如： <p>只写出class Person;）那么编译器又如何知道该配置多少空间呢？ <p>对Java等语言对此问题的解法是，当程序定义出一个对象时，只配置足够空间给一个“指向该对象的指针”使用，如<br>public Person; <p>public static void main(String[] args) <p>{ <p>&nbsp;&nbsp;&nbsp; Person p; <p>} <p>对于C++就如下那样： <p>class Person; <p>int main() <p>{ <p>&nbsp;&nbsp;&nbsp; Person *p;//编译器当要配置一个指针大小的空间的指针给p就可以了。 <p>//Person &amp;p2; 这个理论上也可以，但references object必须“言之有物” <p>return 0; <p>} <p>看回刚才那段代码为什么“Person p;//用C++时编译不通过;”呢？因为它要调用Person constructor。那就是Person的实现细节。 <p>现在可以解说上面的表格了，我的目的是 <strong>去掉#include <strong>“</strong><strong>Person.h</strong><strong>”</strong>并加入class Person; 所以要做有：</strong> <p>1. 将Person child改为Person *child。因为child也是Man的成员，Man的大小与Child相关，而child不是内部类型，它的大小编译器不知道。 <p>2. 将:public Person去掉。因为Man继承Person，所以编译器也要知道Person是怎样实现的，那样才能构造出正确的Man来（为了编译成功，我忍痛割爱了）。 <p>同时我也要对原码作一下解释： <p>/////////Man.h/////////// <p>#pragma once <p>#include "person.h" <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>这里#include “person.h”不但包含了Person的定义，也包含了Person的实现细节，所以是编译成功的。 <p><strong>结论</strong>： <p>1. 当不需要调用类的实现时，包括constructor，copy constructor,assignment operator,member function，甚至是address-of operator时，就不用#include，只要forward declaration就可以了。 <p>2. 当要用到类的上面那些“方法”时，就要#include <p><strong>扩充</strong>： <p>为了加深认识，我分享遇到的另一情况。 <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>virtual void addChild(Person p) = 0;//将Person变为抽象类 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include "person.h"&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>/////////Man.h/////////// <p>#pragma once <p>#include "person.h"&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>#include "person.h"&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person *p);//将形参变为Person* <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>编译成功 <p>/////////Man.h/////////// <p>#pragma once <p>#include "person.h"&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person &amp;p);//将形参变为Person&amp; <p>}; <p>编译成功 <p>为什么出现不能实例化抽象类？我并没有实例化过它。 <p>这是参数的传递问题。当一个变量传给函数时，我们说是实参传给形参（pass-by-value），形参是通过copy constructor建立的，所以就是实例化了一个抽象类。而pass-by-reference和传指针就没问题了。（全文完） <p>参考资料： <p>候捷：《Effective C++》
