
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>头文件中循环引用 - Min's Lounger History</title>
  <meta name="author" content="Mr.Liao">

  
  <meta name="description" content="转自网站：http://hi.baidu.com/shilyx/blog/item/c1e3f7f277e29811b17ec5f2.html 一、类嵌套的疑问 C++头文件重复包含实在是一个令人头痛的问题，前一段时间在做一个简单的数据结构演示程序的时候，不只一次的遇到这种问题。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://pliaohuimin.github.io/blogs/67">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Min's Lounger History" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Min's Lounger History</a></h1>
  
    <h2>All Life Sucks,all we can do is let it suck less</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:pliaohuimin.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">头文件中循环引用</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-11T00:00:00+08:00" pubdate data-updated="true">Aug 11<span>th</span>, 2012</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>转自网站：<a href="http://hi.baidu.com/shilyx/blog/item/c1e3f7f277e29811b17ec5f2.html">http://hi.baidu.com/shilyx/blog/item/c1e3f7f277e29811b17ec5f2.html</a></p> <p><strong>一、类嵌套的疑问</strong> <p>C++头文件重复包含实在是一个令人头痛的问题，前一段时间在做一个简单的数据结构演示程序的时候，不只一次的遇到这种问题。假设我们有两个类A和B，分别定义在各自的有文件A.h和B.h中，但是在A中要用到B，B中也要用到A，但是这样的写法当然是错误的：<br>class B; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B b;<br>}; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A a;<br>};<br>因为在A对象中要开辟一块属于B的空间，而B中又有A的空间，是一个逻辑错误，无法实现的。在这里我们只需要把其中的一个A类中的B类型成员改成指针形式就可以避免这个无限延伸的怪圈了。为什么要更改A而不是B？因为就算你在B中做了类似的动作，也仍然会编译错误，表面上这仅仅上一个先后顺序的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么会这样呢？因为C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据的类型的大小。在预先声明语句class B;之后，编译器已经知道B是一个类，但是其中的数据却是未知的，因此B类型的大小也不知道。这样就造成了编译失败，VC++6.0下会得到如下编译错误：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error C2079: &#8216;b&#8217; uses undefined class &#8216;B&#8217;<br>将A中的b更改为B指针类型之后，由于在特定的平台上，指针所占的空间是一定的（在Win32平台上是4字节），这样可以通过编译。 <p><strong>二、不同头文件中的类的嵌套</strong> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在实际编程中，不同的类一般是放在不同的相互独立的头文件中的，这样两个类在相互引用时又会有不一样的问题。重复编译是问题出现的根本原因。为了保证头文件仅被编译一次，在C++中常用的办法是使用条件编译命令。在头文件中我们常常会看到以下语句段（以VC++6.0自动生成的头文件为例）： <p>#if !defined(AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_)<br>#define AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //很多语句……<br>#endif <p>其中首句#if !defined也经常做#ifndef，作用相同。意思是如果没有定义过这个宏，那么就定义它，然后执行直到#endif的所有语句。如果下次在与要这段代码，由于已经定义了那个宏，因此重复的代码不会被再次执行。这实在是一个巧妙而高效的办法。在高版本的VC++上，还可以使用这个命令来代替以上的所有：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #pragma once<br>它的意思是，本文件内的代码只被使用一次。 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是不要以为使用了这种机制就全部搞定了，比如在以下的代码中： <p>//文件A.h中的代码<br>#pragma once <p>#include &#8220;B.h&#8221; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B* b;<br>}; <p>//文件B.h中的代码<br>#pragma once <p>#include &#8220;A.h&#8221; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A* a;<br>}; <p>这里两者都使用了指针成员，因此嵌套本身不会有什么问题，在主函数前面使用#include &#8220;A.h&#8221;之后，主要编译错误如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error C2501: &#8216;A&#8217; : missing storage-class or type specifiers<br>仍然是类型不能找到的错误。其实这里仍然需要前置声明。分别添加前置声明之后，可以成功编译了。代码形式如下： <p>//文件A.h中的代码<br>#pragma once <p>#include &#8220;B.h&#8221; <p>class B; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B* b;<br>}; <p>//文件B.h中的代码<br>#pragma once <p>#include &#8220;A.h&#8221; <p>class B; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A* a;<br>}; <p>这样至少可以说明，头文件包含代替不了前置声明。有的时候只能依靠前置声明来解决问题。我们还要思考一下，有了前置声明的时候头文件包含还是必要的吗？我们尝试去掉A.h和B.h中的#include行，发现没有出现新的错误。那么究竟什么时候需要前置声明，什么时候需要头文件包含呢？ <p><strong>三、两点原则</strong> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 头文件包含其实是一想很烦琐的工作，不但我们看着累，编译器编译的时候也很累，再加上头文件中常常出现的宏定义。感觉各种宏定义的展开是非常耗时间的，远不如自定义函数来得速度。我仅就不同头文件、源文件间的句则结构问题提出两点原则，仅供参考： <p>第一个原则应该是，如果可以不包含头文件，那就不要包含了。这时候前置声明可以解决问题。如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知。 <p>第二个原则应该是，尽量在CPP文件中包含头文件，而非在头文件中。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类B的前置声明并便宜成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件)。</p></div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Mr.Liao</span></span>

      








  


<time datetime="2012-08-11T00:00:00+08:00" pubdate data-updated="true">Aug 11<span>th</span>, 2012</time>
      


    </p>
    
      <div class="sharing">
  
  
  
  <a class="bshareDiv" href="http://www.bshare.cn/share">Sharing</a><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#uuid=25fcdf85-62f9-400e-b053-627f102edf5a&style=999&img=http%3A%2F%2Fstatic.bshare.cn%2Fimages%2Fbuttons%2Fbox-shareTo-zh.gif&w=147&h=21"></script>
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blogs/49" title="Previous Post: WORDPRESS网站流量统计">&laquo; WORDPRESS网站流量统计</a>
      
      
        <a class="basic-alignment right" href="/blogs/69" title="Next Post: 正确使用#include和前置声明(forward declaration)">正确使用#include和前置声明(forward declaration) &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20140808/new-domain/">申请了新域名</a>
      </li>
    
      <li class="post">
        <a href="/blog/20140805/new-machine-to-octopress/">在新机器上使用octopress写文章</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130902/add-share/">Octopress小工具</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130902/octopress-archive/">赞一个OCTOPRESS的ARCHIVE展示</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130901/from-wp2octopress/">从wordpress迁移到octopress</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Mr.Liao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'minlh';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://pliaohuimin.github.io/blogs/67';
        var disqus_url = 'http://pliaohuimin.github.io/blogs/67';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
