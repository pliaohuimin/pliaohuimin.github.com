
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>正确使用#include和前置声明(forward declaration) - Min's Lounger</title>
	<meta name="author" content="Mr.Liao">

	
	<meta name="description" content="正确使用#include和前置声明(forward Declaration) 转自网站：http://blog.csdn.net/SpriteLW/article/details/965702 差不多一年时间没用过C++写过程序了,由于工作的需要,我又回到了C++的阵形。 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Min's Lounger" type="application/atom+xml">
	
	<link rel="canonical" href="http://pliaohuimin.github.io/blogs/69">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("pliaohuimin@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>
<h1><a href="/">Min's Lounger</a></h1>
<p class="subtitle">All Life Sucks,all we can do is let it suck less</p>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/categories/travelling">Travelling</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:pliaohuimin@gmail.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">正确使用#include和前置声明(forward Declaration)</h1>
	<div class="entry-content" itemprop="articleBody"><p>转自网站：<a href="http://blog.csdn.net/SpriteLW/article/details/965702">http://blog.csdn.net/SpriteLW/article/details/965702</a></p> <p>差不多一年时间没用过C++写过程序了,由于工作的需要,我又回到了C++的阵形。在工作的过程中遇到了很多麻烦，当我往工程里加一个类，而且那个类又与工程里的类相关，如有那个类型的成员变量。情况如下 <p>//////A.h/////////// <p>class A <p>{ <p>&#8230;&#8230;. <p>}; <p>////////B.h////////// <p>class B:A <p>{ <p>&#8230;. <p>A member; <p>} <p>结果，编译就会出错，说找不到类形A。解决的办法是在B.h里#include “A.h”。但是有时候不用#include “A.h”，只要在classB:A前加class A;就可以了。更严重的是不但要#include “A.h”，还要class A;。 <p>起初觉得没问题，因为这样搞来搞去总会编译通过的，而且不会让程序变大，因为有#ifndef&#8230;#endif和#pragma once控制。直到有一次，我需要那些常量放到一个文件中“const.h”，然后include到其它需要它的类中，结果怎么也编译不成功（因为文件多了，而且每个文件都这样互相include，把我也蒙了） <p>直到今天终于从《Effective C++》里找到原理。现向大家分享一下，首先我以下面这个类结构作例子。（先不管我为什么不加一个Woman，为什么Man就有child，我只是作例子解说，绝没有性别歧视。 <p><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/SpriteLW/gif_1.gif"> <p>代码如下： <p>////////////main.h////////////// <p>#include &#8220;stdafx.h&#8221; <p>#include &#8220;man.h&#8221; <p>int main(){ <p>&nbsp;&nbsp;&nbsp; Man m; <p>return 0; <p>} <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>}; <p>////////Person.cpp/////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./person.h&#8221; <p>Person::Person(void){ <p>} <p>Person::~Person(void){ <p>} <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////////Man.cpp////////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./man.h&#8221; <p>Man::Man(void){ <p>} <p>Man::~Man(void){ <p>} <p>上述代码，编译运行一切正常。现在我作以下修改： <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉 <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>error C2504: “Person” : 未定义基类 <p>error C2504: “Person” : 未定义基类 <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person <strong>child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>error C2504: “Person” : 未定义基类 <p>编译通过 <p>要讲解上面的代码还要一些预备知备，看下面代码： <p>int main() <p>{ <p>int x; <p>&nbsp;&nbsp;&nbsp; Person p;//用C++时编译不通过; <p>} <p>当编译器看到x定义式时，它们知道必须配置足够的空间以放置一个int。没问题，每个编译器都知道int有多大。然而当编译器看到p的定义式时，虽然它们也知道必须配置足够空间以放置一个Person，但一个Person对象有多大呢？编译器获得这项信息的唯一办法就是询问class定义式。然而class的定义式可以合法地不列出实现细节（如： <p>只写出class Person;）那么编译器又如何知道该配置多少空间呢？ <p>对Java等语言对此问题的解法是，当程序定义出一个对象时，只配置足够空间给一个“指向该对象的指针”使用，如<br>public Person; <p>public static void main(String[] args) <p>{ <p>&nbsp;&nbsp;&nbsp; Person p; <p>} <p>对于C++就如下那样： <p>class Person; <p>int main() <p>{ <p>&nbsp;&nbsp;&nbsp; Person *p;//编译器当要配置一个指针大小的空间的指针给p就可以了。 <p>//Person &amp;p2; 这个理论上也可以，但references object必须“言之有物” <p>return 0; <p>} <p>看回刚才那段代码为什么“Person p;//用C++时编译不通过;”呢？因为它要调用Person constructor。那就是Person的实现细节。 <p>现在可以解说上面的表格了，我的目的是 <strong>去掉#include <strong>“</strong><strong>Person.h</strong><strong>”</strong>并加入class Person; 所以要做有：</strong> <p>1. 将Person child改为Person *child。因为child也是Man的成员，Man的大小与Child相关，而child不是内部类型，它的大小编译器不知道。 <p>2. 将:public Person去掉。因为Man继承Person，所以编译器也要知道Person是怎样实现的，那样才能构造出正确的Man来（为了编译成功，我忍痛割爱了）。 <p>同时我也要对原码作一下解释： <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>这里#include “person.h”不但包含了Person的定义，也包含了Person的实现细节，所以是编译成功的。 <p><strong>结论</strong>： <p>1. 当不需要调用类的实现时，包括constructor，copy constructor,assignment operator,member function，甚至是address-of operator时，就不用#include，只要forward declaration就可以了。 <p>2. 当要用到类的上面那些“方法”时，就要#include <p><strong>扩充</strong>： <p>为了加深认识，我分享遇到的另一情况。 <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>virtual void addChild(Person p) = 0;//将Person变为抽象类 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person *p);//将形参变为Person</strong> <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>编译成功 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person &amp;p);//将形参变为Person&amp; <p>}; <p>编译成功 <p>为什么出现不能实例化抽象类？我并没有实例化过它。 <p>这是参数的传递问题。当一个变量传给函数时，我们说是实参传给形参（pass-by-value），形参是通过copy constructor建立的，所以就是实例化了一个抽象类。而pass-by-reference和传指针就没问题了。（全文完） <p>参考资料： <p>候捷：《Effective C++》</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Mr.Liao


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	

<script type="text/javascript">
      var disqus_shortname = 'minlh';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://pliaohuimin.github.io/blogs/69';
        var disqus_url = 'http://pliaohuimin.github.io/blogs/69';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










</body>
</html>
