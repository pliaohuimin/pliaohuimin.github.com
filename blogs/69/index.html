
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>正确使用#include和前置声明(forward declaration) - Min's Lounger History</title>
  <meta name="author" content="Mr.Liao">

  
  <meta name="description" content="转自网站：http://blog.csdn.net/SpriteLW/article/details/965702 差不多一年时间没用过C++写过程序了,由于工作的需要,我又回到了C++的阵形。在工作的过程中遇到了很多麻烦，当我往工程里加一个类，而且那个类又与工程里的类相关，如有那个类型的成员变量 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.minlh.tk/blogs/69">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Min's Lounger History" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Min's Lounger History</a></h1>
  
    <h2>All Life Sucks,all we can do is let it suck less</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.minlh.tk" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">正确使用#include和前置声明(forward Declaration)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-11T00:00:00+08:00" pubdate data-updated="true">Aug 11<span>th</span>, 2012</time>
        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>转自网站：<a href="http://blog.csdn.net/SpriteLW/article/details/965702">http://blog.csdn.net/SpriteLW/article/details/965702</a></p> <p>差不多一年时间没用过C++写过程序了,由于工作的需要,我又回到了C++的阵形。在工作的过程中遇到了很多麻烦，当我往工程里加一个类，而且那个类又与工程里的类相关，如有那个类型的成员变量。情况如下 <p>//////A.h/////////// <p>class A <p>{ <p>&#8230;&#8230;. <p>}; <p>////////B.h////////// <p>class B:A <p>{ <p>&#8230;. <p>A member; <p>} <p>结果，编译就会出错，说找不到类形A。解决的办法是在B.h里#include “A.h”。但是有时候不用#include “A.h”，只要在classB:A前加class A;就可以了。更严重的是不但要#include “A.h”，还要class A;。 <p>起初觉得没问题，因为这样搞来搞去总会编译通过的，而且不会让程序变大，因为有#ifndef&#8230;#endif和#pragma once控制。直到有一次，我需要那些常量放到一个文件中“const.h”，然后include到其它需要它的类中，结果怎么也编译不成功（因为文件多了，而且每个文件都这样互相include，把我也蒙了） <p>直到今天终于从《Effective C++》里找到原理。现向大家分享一下，首先我以下面这个类结构作例子。（先不管我为什么不加一个Woman，为什么Man就有child，我只是作例子解说，绝没有性别歧视。 <p><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/SpriteLW/gif_1.gif"> <p>代码如下： <p>////////////main.h////////////// <p>#include &#8220;stdafx.h&#8221; <p>#include &#8220;man.h&#8221; <p>int main(){ <p>&nbsp;&nbsp;&nbsp; Man m; <p>return 0; <p>} <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>}; <p>////////Person.cpp/////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./person.h&#8221; <p>Person::Person(void){ <p>} <p>Person::~Person(void){ <p>} <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////////Man.cpp////////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./man.h&#8221; <p>Man::Man(void){ <p>} <p>Man::~Man(void){ <p>} <p>上述代码，编译运行一切正常。现在我作以下修改： <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉 <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>error C2504: “Person” : 未定义基类 <p>error C2504: “Person” : 未定义基类 <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person <strong>child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>error C2504: “Person” : 未定义基类 <p>编译通过 <p>要讲解上面的代码还要一些预备知备，看下面代码： <p>int main() <p>{ <p>int x; <p>&nbsp;&nbsp;&nbsp; Person p;//用C++时编译不通过; <p>} <p>当编译器看到x定义式时，它们知道必须配置足够的空间以放置一个int。没问题，每个编译器都知道int有多大。然而当编译器看到p的定义式时，虽然它们也知道必须配置足够空间以放置一个Person，但一个Person对象有多大呢？编译器获得这项信息的唯一办法就是询问class定义式。然而class的定义式可以合法地不列出实现细节（如： <p>只写出class Person;）那么编译器又如何知道该配置多少空间呢？ <p>对Java等语言对此问题的解法是，当程序定义出一个对象时，只配置足够空间给一个“指向该对象的指针”使用，如<br>public Person; <p>public static void main(String[] args) <p>{ <p>&nbsp;&nbsp;&nbsp; Person p; <p>} <p>对于C++就如下那样： <p>class Person; <p>int main() <p>{ <p>&nbsp;&nbsp;&nbsp; Person *p;//编译器当要配置一个指针大小的空间的指针给p就可以了。 <p>//Person &amp;p2; 这个理论上也可以，但references object必须“言之有物” <p>return 0; <p>} <p>看回刚才那段代码为什么“Person p;//用C++时编译不通过;”呢？因为它要调用Person constructor。那就是Person的实现细节。 <p>现在可以解说上面的表格了，我的目的是 <strong>去掉#include <strong>“</strong><strong>Person.h</strong><strong>”</strong>并加入class Person; 所以要做有：</strong> <p>1. 将Person child改为Person *child。因为child也是Man的成员，Man的大小与Child相关，而child不是内部类型，它的大小编译器不知道。 <p>2. 将:public Person去掉。因为Man继承Person，所以编译器也要知道Person是怎样实现的，那样才能构造出正确的Man来（为了编译成功，我忍痛割爱了）。 <p>同时我也要对原码作一下解释： <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>这里#include “person.h”不但包含了Person的定义，也包含了Person的实现细节，所以是编译成功的。 <p><strong>结论</strong>： <p>1. 当不需要调用类的实现时，包括constructor，copy constructor,assignment operator,member function，甚至是address-of operator时，就不用#include，只要forward declaration就可以了。 <p>2. 当要用到类的上面那些“方法”时，就要#include <p><strong>扩充</strong>： <p>为了加深认识，我分享遇到的另一情况。 <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>virtual void addChild(Person p) = 0;//将Person变为抽象类 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person *p);//将形参变为Person</strong> <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>编译成功 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person &amp;p);//将形参变为Person&amp; <p>}; <p>编译成功 <p>为什么出现不能实例化抽象类？我并没有实例化过它。 <p>这是参数的传递问题。当一个变量传给函数时，我们说是实参传给形参（pass-by-value），形参是通过copy constructor建立的，所以就是实例化了一个抽象类。而pass-by-reference和传指针就没问题了。（全文完） <p>参考资料： <p>候捷：《Effective C++》</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Mr.Liao</span></span>

      








  


<time datetime="2012-08-11T00:00:00+08:00" pubdate data-updated="true">Aug 11<span>th</span>, 2012</time>
      


    </p>
    
      <div class="sharing">
  
  
  
  <a class="bshareDiv" href="http://www.bshare.cn/share">Sharing</a><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#uuid=25fcdf85-62f9-400e-b053-627f102edf5a&style=999&img=http%3A%2F%2Fstatic.bshare.cn%2Fimages%2Fbuttons%2Fbox-shareTo-zh.gif&w=147&h=21"></script>
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blogs/67" title="Previous Post: 头文件中循环引用">&laquo; 头文件中循环引用</a>
      
      
        <a class="basic-alignment right" href="/blogs/71" title="Next Post: typedef struct的前置声明">typedef struct的前置声明 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20140805/new-machine-to-octopress/">New Machine to Octopress</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130902/add-share/">Octopress小工具</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130902/octopress-archive/">赞一个OCTOPRESS的ARCHIVE展示</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130901/from-wp2octopress/">从wordpress迁移到octopress</a>
      </li>
    
      <li class="post">
        <a href="/blog/20130830/kai-shi-octopress/">开始OCTOPRESS</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Mr.Liao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'minlh';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://www.minlh.tk/blogs/69';
        var disqus_url = 'http://www.minlh.tk/blogs/69';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
