
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Min's Lounger</title>
	<meta name="author" content="Mr.Liao">

	
	<meta name="description" content="Aug 11th, 2012 Comments 灰度发布 转自：http://sd.csdn.net/a/20120515/2805581.html 所谓灰度发布，是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Min's Lounger" type="application/atom+xml">
	
	<link rel="canonical" href="http://pliaohuimin.github.io/blog/page/7/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("pliaohuimin@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>
<h1><a href="/">Min's Lounger</a></h1>
<p class="subtitle">All Life Sucks,all we can do is let it suck less</p>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/categories/travelling">Travelling</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:pliaohuimin@gmail.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/77#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/77" itemprop="url">灰度发布</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自：<a href="http://sd.csdn.net/a/20120515/2805581.html">http://sd.csdn.net/a/20120515/2805581.html</a></p> <p>所谓<strong>灰度发布</strong>，是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面 来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。(在腾讯，灰度发布是最常采用的发布方式之一)</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/73#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/73" itemprop="url">20120811- 腾讯iron敏捷开发讲座</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><b>Scrum</b>是一种迭代式增量软件开发过程，通常用于<a href="http://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">敏捷软件开发</a>。</p> <p><strong>Scrum中的主要角色</strong>包括： <ol> <li>&#8216;Scrum Master&#8217; 是Scrum教练和团队带头人，确保团队合理的运作Scrum，并帮助团队移除实施中的障碍；  <li><b>产品负责人</b>(Product Owner)，确定产品的方向和愿景，定义产品发布的内容、优先级及交付时间，为产品ROI负责；  <li><b>开发团队</b>(Team)，一个跨职能的小团队，人数5-9人，团队拥有交付可用软件需要的各种技能。(key words:7,cross)</li><p></ol> <p>在每一次冲刺（一个15到30天的周期，其长度由开发团队决定）当中，开发团队创建可用的（可以随时推出）软件的一个增量。每一个冲刺所要实现的功能来自产品订单（product backlog）。产品订单是按照优先级排列的要完成的工作的概要的需求，哪些订单项会被加入一次冲刺将由冲刺计划会议决定。 在会议中，产品负责人告诉开发团队他需要完成产品订单中的哪些订单项。开发团队决定在下一次冲刺中他们能够承诺完成多少订单项。<sup><a href="http://zh.wikipedia.org/wiki/Scrum#cite_note-schwaber-3"><sup class="footnote" id="fnr4"><a href="#fn4">4</a></sup></a></sup> 在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog），这意味着在一个冲刺中需求是被冻结的。(key word: product backlog(what)-&gt;sprint backlog(how))</p> <p><img alt="File:Scrum process zh.svg" src="http://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Scrum_process_zh.svg/800px-Scrum_process_zh.svg.png"></p> <h4>Scrum会议</h4> <p>在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。每日站立会议有一些具体的指导原则： <ul> <li>会议准时开始。对于迟到者团队常常会制定惩罚措施（例如罚款，做俯卧撑，在脖子上挂橡胶鸡玩具）  <li>欢迎所有人参加，但只有&quot;猪&quot;可以发言。  <li>不论团队规模大小，会议被限制在15分钟。  <li>所有出席者都应站立。（有助于保持会议简短）  <li>会议应在固定地点和每天的同一时间举行。</li></ul> <p>在会议上，每个团队成员需要回答三个问题：<sup><a href="http://zh.wikipedia.org/wiki/Scrum#cite_note-schwaber-3"><sup class="footnote" id="fnr4"><a href="#fn4">4</a></sup></a></sup> <ul> <li>今天你完成了那些工作？  <li>明天你打算做什么？  <li>完成你的目标是否存在什么障碍？（Scrum主管需要记下这些障碍）</li></ul> <p><strong><span class="caps">REVIEW</span></strong></p> <p>每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。 <p>Scrum提倡所有团队成员坐在一起工作，进行口头交流，以及强调项目有关的规范（disciplines），这些有助于创造自我组织的团队。 <p>&nbsp; <p><strong>文档:</strong> <h5>产品订单</h5> <p>产品订单（<b>product backlog</b>）是整个项目的概要文档。产品订单包括所有所需特性的粗略的描述。产品订单是关于将要创建的什么产品。产品订单是开放的，每个人都可以编辑。产品订单包括粗略的估算，通常以天为单位。估算将帮助产品负责人衡量时间表和优先级（例如，如果&quot;增加拼写检查&quot;特性的估计需要花3天或3个月，将影响产品负责人对该特性的渴望）。 <h5>冲刺订单</h5> <p>冲刺订单（<b>sprint backlog</b>）是大大细化了的文档，包含团队如何实现下一个冲刺的需求的信息。任务被分解为以小时为单位，没有任务可以超过16个小时。如果一个任务超过16个小时，那么它就应该被进一步分解。冲刺订单上的任务不会被分派，而是由团队成员签名认领他们喜爱的任务。 <h5>燃尽图</h5> <p><a href="http://zh.wikipedia.org/w/index.php?title=%E7%87%83%E5%B0%BD%E5%9B%BE&amp;action=edit&amp;redlink=1">燃尽图</a>（burn down chart）是一个公开展示的图表，显示当前冲刺中未完成的任务数目，或在冲刺订单上未完成的订单项的数目。不要把燃尽图与<a href="http://zh.wikipedia.org/wiki/%E6%8C%A3%E5%80%BC%E7%AE%A1%E7%90%86">挣值图</a>相混淆。A burn down chart could be flat for most of the period covered by a sprint and yet the project could still be on schedule. <p><strong>价值观：</strong> <ul> <li><b>人和交互</b> 重于过程和工具。  <li><b>可以工作的软件</b> 重于求全责备的文档。  <li><b>客户协作</b>重于合同谈判。  <li><b>随时应对变化</b>重于循规蹈矩。</li></ul> <p>其中位于右边的内容虽然也有其价值，但是左边的内容最为重要。</p></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/71#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/71" itemprop="url">Typedef Struct的前置声明</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>参照网站：<a href="http://dreamume.blog.163.com/blog/static/184923719201236115353586/">http://dreamume.blog.163.com/blog/static/184923719201236115353586/</a></p> <p>如果有typedef struct，则需要把这句拷贝作为前置声明。<br>有些typedef struct语句可能在某些库头文件中，很难找，如果遇到这种情况，可以假定一个错误的定义，然后通过gcc的编译提示找到该句。<br>例如：<br>typedef struct STruncData SPlainData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; STruncData是随意写的 */<br>则gcc编译会提示找到两处不同的SPainData定义，这样就找出了正确的那个，拷贝出来直接使用即可。 <p><strong>注：没有测试过，待验证。</strong></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/69#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/69" itemprop="url">正确使用#include和前置声明(forward Declaration)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自网站：<a href="http://blog.csdn.net/SpriteLW/article/details/965702">http://blog.csdn.net/SpriteLW/article/details/965702</a></p> <p>差不多一年时间没用过C++写过程序了,由于工作的需要,我又回到了C++的阵形。在工作的过程中遇到了很多麻烦，当我往工程里加一个类，而且那个类又与工程里的类相关，如有那个类型的成员变量。情况如下 <p>//////A.h/////////// <p>class A <p>{ <p>&#8230;&#8230;. <p>}; <p>////////B.h////////// <p>class B:A <p>{ <p>&#8230;. <p>A member; <p>} <p>结果，编译就会出错，说找不到类形A。解决的办法是在B.h里#include “A.h”。但是有时候不用#include “A.h”，只要在classB:A前加class A;就可以了。更严重的是不但要#include “A.h”，还要class A;。 <p>起初觉得没问题，因为这样搞来搞去总会编译通过的，而且不会让程序变大，因为有#ifndef&#8230;#endif和#pragma once控制。直到有一次，我需要那些常量放到一个文件中“const.h”，然后include到其它需要它的类中，结果怎么也编译不成功（因为文件多了，而且每个文件都这样互相include，把我也蒙了） <p>直到今天终于从《Effective C++》里找到原理。现向大家分享一下，首先我以下面这个类结构作例子。（先不管我为什么不加一个Woman，为什么Man就有child，我只是作例子解说，绝没有性别歧视。 <p><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/SpriteLW/gif_1.gif"> <p>代码如下： <p>////////////main.h////////////// <p>#include &#8220;stdafx.h&#8221; <p>#include &#8220;man.h&#8221; <p>int main(){ <p>&nbsp;&nbsp;&nbsp; Man m; <p>return 0; <p>} <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>}; <p>////////Person.cpp/////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./person.h&#8221; <p>Person::Person(void){ <p>} <p>Person::~Person(void){ <p>} <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////////Man.cpp////////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./man.h&#8221; <p>Man::Man(void){ <p>} <p>Man::~Man(void){ <p>} <p>上述代码，编译运行一切正常。现在我作以下修改： <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉 <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>error C2504: “Person” : 未定义基类 <p>error C2504: “Person” : 未定义基类 <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person <strong>child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>error C2504: “Person” : 未定义基类 <p>编译通过 <p>要讲解上面的代码还要一些预备知备，看下面代码： <p>int main() <p>{ <p>int x; <p>&nbsp;&nbsp;&nbsp; Person p;//用C++时编译不通过; <p>} <p>当编译器看到x定义式时，它们知道必须配置足够的空间以放置一个int。没问题，每个编译器都知道int有多大。然而当编译器看到p的定义式时，虽然它们也知道必须配置足够空间以放置一个Person，但一个Person对象有多大呢？编译器获得这项信息的唯一办法就是询问class定义式。然而class的定义式可以合法地不列出实现细节（如： <p>只写出class Person;）那么编译器又如何知道该配置多少空间呢？ <p>对Java等语言对此问题的解法是，当程序定义出一个对象时，只配置足够空间给一个“指向该对象的指针”使用，如<br>public Person; <p>public static void main(String[] args) <p>{ <p>&nbsp;&nbsp;&nbsp; Person p; <p>} <p>对于C++就如下那样： <p>class Person; <p>int main() <p>{ <p>&nbsp;&nbsp;&nbsp; Person *p;//编译器当要配置一个指针大小的空间的指针给p就可以了。 <p>//Person &amp;p2; 这个理论上也可以，但references object必须“言之有物” <p>return 0; <p>} <p>看回刚才那段代码为什么“Person p;//用C++时编译不通过;”呢？因为它要调用Person constructor。那就是Person的实现细节。 <p>现在可以解说上面的表格了，我的目的是 <strong>去掉#include <strong>“</strong><strong>Person.h</strong><strong>”</strong>并加入class Person; 所以要做有：</strong> <p>1. 将Person child改为Person *child。因为child也是Man的成员，Man的大小与Child相关，而child不是内部类型，它的大小编译器不知道。 <p>2. 将:public Person去掉。因为Man继承Person，所以编译器也要知道Person是怎样实现的，那样才能构造出正确的Man来（为了编译成功，我忍痛割爱了）。 <p>同时我也要对原码作一下解释： <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>这里#include “person.h”不但包含了Person的定义，也包含了Person的实现细节，所以是编译成功的。 <p><strong>结论</strong>： <p>1. 当不需要调用类的实现时，包括constructor，copy constructor,assignment operator,member function，甚至是address-of operator时，就不用#include，只要forward declaration就可以了。 <p>2. 当要用到类的上面那些“方法”时，就要#include <p><strong>扩充</strong>： <p>为了加深认识，我分享遇到的另一情况。 <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>virtual void addChild(Person p) = 0;//将Person变为抽象类 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person *p);//将形参变为Person</strong> <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>编译成功 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person &amp;p);//将形参变为Person&amp; <p>}; <p>编译成功 <p>为什么出现不能实例化抽象类？我并没有实例化过它。 <p>这是参数的传递问题。当一个变量传给函数时，我们说是实参传给形参（pass-by-value），形参是通过copy constructor建立的，所以就是实例化了一个抽象类。而pass-by-reference和传指针就没问题了。（全文完） <p>参考资料： <p>候捷：《Effective C++》
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/67#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/67" itemprop="url">头文件中循环引用</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自网站：<a href="http://hi.baidu.com/shilyx/blog/item/c1e3f7f277e29811b17ec5f2.html">http://hi.baidu.com/shilyx/blog/item/c1e3f7f277e29811b17ec5f2.html</a></p> <p><strong>一、类嵌套的疑问</strong> <p>C++头文件重复包含实在是一个令人头痛的问题，前一段时间在做一个简单的数据结构演示程序的时候，不只一次的遇到这种问题。假设我们有两个类A和B，分别定义在各自的有文件A.h和B.h中，但是在A中要用到B，B中也要用到A，但是这样的写法当然是错误的：<br>class B; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B b;<br>}; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A a;<br>};<br>因为在A对象中要开辟一块属于B的空间，而B中又有A的空间，是一个逻辑错误，无法实现的。在这里我们只需要把其中的一个A类中的B类型成员改成指针形式就可以避免这个无限延伸的怪圈了。为什么要更改A而不是B？因为就算你在B中做了类似的动作，也仍然会编译错误，表面上这仅仅上一个先后顺序的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么会这样呢？因为C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据的类型的大小。在预先声明语句class B;之后，编译器已经知道B是一个类，但是其中的数据却是未知的，因此B类型的大小也不知道。这样就造成了编译失败，VC++6.0下会得到如下编译错误：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error C2079: &#8216;b&#8217; uses undefined class &#8216;B&#8217;<br>将A中的b更改为B指针类型之后，由于在特定的平台上，指针所占的空间是一定的（在Win32平台上是4字节），这样可以通过编译。 <p><strong>二、不同头文件中的类的嵌套</strong> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在实际编程中，不同的类一般是放在不同的相互独立的头文件中的，这样两个类在相互引用时又会有不一样的问题。重复编译是问题出现的根本原因。为了保证头文件仅被编译一次，在C++中常用的办法是使用条件编译命令。在头文件中我们常常会看到以下语句段（以VC++6.0自动生成的头文件为例）： <p>#if !defined(AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_)<br>#define AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //很多语句……<br>#endif <p>其中首句#if !defined也经常做#ifndef，作用相同。意思是如果没有定义过这个宏，那么就定义它，然后执行直到#endif的所有语句。如果下次在与要这段代码，由于已经定义了那个宏，因此重复的代码不会被再次执行。这实在是一个巧妙而高效的办法。在高版本的VC++上，还可以使用这个命令来代替以上的所有：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #pragma once<br>它的意思是，本文件内的代码只被使用一次。 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是不要以为使用了这种机制就全部搞定了，比如在以下的代码中： <p>//文件A.h中的代码<br>#pragma once <p>#include &#8220;B.h&#8221; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B* b;<br>}; <p>//文件B.h中的代码<br>#pragma once <p>#include &#8220;A.h&#8221; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A* a;<br>}; <p>这里两者都使用了指针成员，因此嵌套本身不会有什么问题，在主函数前面使用#include &#8220;A.h&#8221;之后，主要编译错误如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error C2501: &#8216;A&#8217; : missing storage-class or type specifiers<br>仍然是类型不能找到的错误。其实这里仍然需要前置声明。分别添加前置声明之后，可以成功编译了。代码形式如下： <p>//文件A.h中的代码<br>#pragma once <p>#include &#8220;B.h&#8221; <p>class B; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B* b;<br>}; <p>//文件B.h中的代码<br>#pragma once <p>#include &#8220;A.h&#8221; <p>class B; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A* a;<br>}; <p>这样至少可以说明，头文件包含代替不了前置声明。有的时候只能依靠前置声明来解决问题。我们还要思考一下，有了前置声明的时候头文件包含还是必要的吗？我们尝试去掉A.h和B.h中的#include行，发现没有出现新的错误。那么究竟什么时候需要前置声明，什么时候需要头文件包含呢？ <p><strong>三、两点原则</strong> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 头文件包含其实是一想很烦琐的工作，不但我们看着累，编译器编译的时候也很累，再加上头文件中常常出现的宏定义。感觉各种宏定义的展开是非常耗时间的，远不如自定义函数来得速度。我仅就不同头文件、源文件间的句则结构问题提出两点原则，仅供参考： <p>第一个原则应该是，如果可以不包含头文件，那就不要包含了。这时候前置声明可以解决问题。如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知。 <p>第二个原则应该是，尽量在CPP文件中包含头文件，而非在头文件中。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类B的前置声明并便宜成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件)。</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-10T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 10<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/webbuilding/'>WebBuilding</a>


</div>
		
			<span class="comments"><a href="/blogs/49#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/49" itemprop="url">WORDPRESS网站流量统计</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>参考网站：</p> <p><a href="http://www.luyouqiwo.com/110/2012/0705/8871.html">http://www.luyouqiwo.com/110/2012/0705/8871.html</a></p> <p><a href="http://www.x-berry.com/traffic-statistics">http://www.x-berry.com/traffic-statistics</a></p> <p>在<a href="http://cnzz.com/">http://cnzz.com/</a>上注册账号，填写个人网站信息。将产生一些脚本，选择你喜欢的类型，拷贝相关代码。</p> <p>登录到你的WORDPRESS后台，选择APPERENCE-&gt;<span class="caps">EDITOR</span>-&gt;<span class="caps">FOOTER</span>.PHP，</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb.png" width="181" height="211"></a></p> <p>将拷贝的脚本粘贴到&lt;/body&gt;之前，保存即可。</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image1.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb1.png" width="236" height="98"></a></p> <p>如果找不到保存按键</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image2.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb2.png" width="244" height="67"></a></p> <p>而是没有修改权限的提示</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image3.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb3.png" width="244" height="38"></a>，</p> <p>可直接在你发布代码的主机上修改相关文件的代码也是可行的，或者修改相关文件的权限。</p> <p>再次登录你的网站，可发现在页面最下面出现你添加的统计字样，</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image4.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb4.png" width="139" height="48"></a></p> <p>点击它可查看统计数据。</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image5.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb5.png" width="244" height="56"></a></p> <p>查看统计数据输入的密码可在cnzz账户上设置。</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image6.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb6.png" width="244" height="109"></a></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-04T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 4<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/46#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/46" itemprop="url">左手练习</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote> <p>url:<a href="http://my.ku6.com/watch?v=bmEAvrzqmMrg6Gwb#share">http://my.ku6.com/watch?v=bmEAvrzqmMrg6Gwb#share</a></p><p></blockquote> <p>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</p> <p>食指 中指 无名指 小指</p> <p>手指垂直指板,靠近品丝,大拇指在琴劲后面的正中间,大拇指与中指相对,手腕向前推,成90度.大拇指不要太用劲。</p> <p>按下去了就不要再动。</p></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-04T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 4<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/43#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/43" itemprop="url">基本乐理知识</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>url:<a href="http://my.ku6.com/watch?v=NbK3FrboMm5Vj33W#share">http://my.ku6.com/watch?v=NbK3FrboMm5Vj33W#share</a></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i</p> <p>唱名：do（全） re（全） mi（半） fa（全）  sou（全）  la（全）  si（半）do</p> <p>音名：CDEFGABC</p> <p>同一根弦，相邻为半，相隔为全</p> <p>各空弦发音：从第一弦到第六弦分别为：E（mi)B(do)G(sou)D(re)A(la)E(mi)</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-04T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 4<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/41#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/41" itemprop="url">吉他类型</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><strong>民谣吉它：<img alt="吉他类型详解" src="http://www.sunjita.com/class/jtzx7rt/images/minyaojita.gif"></strong></p> <p><strong>电吉它：<img alt="吉他类型详解" src="http://www.sunjita.com/class/jtzx7rt/images/dianjita.gif"></strong></p> <p><strong>古典吉它：<img alt="吉他类型详解" src="http://www.sunjita.com/class/jtzx7rt/images/gudianjita.gif"></strong></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-07-28T00:00:00-07:00" data-updated="true" itemprop="datePublished">Jul 28<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/35#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/35" itemprop="url">Accustoming Yourself to C++</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2><strong>item01:view c++ as a federation of languages.</strong></h2>
<p>c++并不是一个带有一组守则的一体语言px是从四个次语言（C,Object-Oriented C++, Template C++,STL）组成的联邦政府，每个次语言都有自己的规约。当你从某个次语言切换到哪一个，遵循那语言的编程守则和策略。</p>

	<ol>
		<li>item02:Prefer consts,enums, and inlines to #defines.<br />
<p>这个条款或许改为”宁可以编译器替换预处理器“比较好。因为或许#define 不被视为语言的一部份。那正是它的问题所在。</p><br />
<p><strong>const:</strong>使用#define定义的常量不在记号表(symbol table)内，出问题时会让你很难追踪排查，包括编译对错误的排查和在调试阶段对问题的排查。</p><br />
<p>此外，使用const代码#define定义常量，能减少目标码（object code），因为预处理器会盲目地将宏名称替换。</p><br />
<p>另外，const比#define多了两个用途：</p><br />
<p>第一是定义常量指针。如:const char* const authorName = “SCOTT MEYERS”。这里值得提醒你的是，string对像通常比其前辈char*-based合宜，所以上述的authorName往往定义成这样更好些：</p><br />
<p>const std::string authorName(”SCOTT MEYERS”);</p><br />
<p>第二是class专属常量。#define不重视作用域，也不能提供任何封装性。</p><br />
<p>&nbsp;</p><br />
<p><strong>enum hack</strong>：一个属于枚举类型(enumerated type)的数值可权充ints被使用。取一个enum的地址是不合法的。如果你不想让别人获得一个pointer或reference指向你的某个整数常量，enum可以帮助你实现这个约束。</p><br />
<p>&nbsp;</p><br />
<p><strong>template inline:</strong>使用它来替换宏定义的函数，可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全性(type safety)。</p><br />
<p>&nbsp;</p></li>
		<li>item03:Use const whenever possible<br />
<p>bitwise constness &amp;&amp; logical constness</p><br />
<p>mutable</p><br />
<p>在const和non-const成员函数中避免重复：令non-const调用其const是一个避免代码重复的安全做法。反向做法&#8212;令const版本调用non-const版本以避免重复是不可取的。</p><br />
<p>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p><br />
<p>编译器强制实施bitwise constness，但你编写程序时应该使用&quot;概念上的常量性(conceptual constness)“。</p><br />
<p>当const 和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</p></li>
	</ol>
		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/6/" class="prev">Prev</a>
    
    
        <a href="/blog/page/8/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Mr.Liao


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	

<script type="text/javascript">
      var disqus_shortname = 'minlh';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










</body>
</html>
