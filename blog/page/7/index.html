
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Min's Lounger</title>
	<meta name="author" content="Mr.Liao">

	
	<meta name="description" content="Aug 21st, 2012 Comments Vim缩进设置 参考网站：http://linux-wiki.cn/wiki/zh-hans/Vim%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E8%AE%BE%E7%BD%AE常用设置缩进设置最常用的是：: &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Min's Lounger" type="application/atom+xml">
	
	<link rel="canonical" href="http://pliaohuimin.github.io/blog/page/7/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("pliaohuimin@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>
<h1><a href="/">Min's Lounger</a></h1>
<p class="subtitle">All Life Sucks,all we can do is let it suck less</p>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/categories/travelling">Travelling</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:pliaohuimin@gmail.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-21T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 21<span>st</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/92#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/92" itemprop="url">Vim缩进设置</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>参考网站：<a href="http://linux-wiki.cn/wiki/zh-hans/Vim%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E8%AE%BE%E7%BD%AE" title="http://linux-wiki.cn/wiki/zh-hans/Vim%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E8%AE%BE%E7%BD%AE">http://linux-wiki.cn/wiki/zh-hans/Vim%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E8%AE%BE%E7%BD%AE</a></p><p>常用设置</p><p>缩进设置最常用的是：</p><p>:filetype indent on</p><p>它将开启针对文件具体类型的缩进。</p><p>下面的选项需要在命令模式下用set设置的选项的含义。使用方法如：</p><p>set ci # 开启cindent</p><p>set noet # 关闭expandtab</p><p>set sw=4 # shiftwidth=4</p><p>上述设置可以写到~/.vimrc中：</p><p>filetype indent on</p><p>set ci</p><p>set noet</p><p>set sw=4</p><p></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-20T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 20<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/90#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/90" itemprop="url">去掉SHELL的提示音和VI的提示音</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>SHELL：</p>
<p>用root用户打开/etc/inputrc，将下面的一行注释：</p>
<p>#set bell-style none</p>
<p>在下面添加多一行：<br />
set bell-style off</p>
<p>重新打开终端，即可生效。</p>
<p>&nbsp;</p>
<p>VI：</p>
<p>打开~/.vimrc（如果打不到该文件，可以自己创建一个），往里面添加多一行：</p>
<p>set vb t_vb=<br />
下次使用vi时即可生效。</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-14T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 14<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/87#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/87" itemprop="url">(转）linux下多线程 之 Pthread_detach(pthread_self())</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><a href="http://blog.csdn.net/Lethe1989/article/details/5191165">转自：http://blog.csdn.net/Lethe1989/article/details/5191165</a></p> <p>多线程稍微看了下还能接受没想象中的难，写了个示例程序运行修改运行修改几遍后也大致明白了。<br>写个碰到的问题，记录下自己的技术之路点滴<br>pthread_detach(pthread_self())<br>linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态，<br>如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。<br>若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。<br>unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join.<br>摘自&nbsp; http://kb.cnblogs.com/a/1285801/ <p>其实简单的说就是在线程函数头加上 pthread_detach(pthread_self())的话，线程状态改变，在函数尾部直接 pthread_exit线程就会自动退出。省去了给线程擦屁股的麻烦</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-13T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 13<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/85#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/85" itemprop="url">认识和弦以及右手的练习</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>参考网站：<a href="http://v.youku.com/v_show/id_XMzE0NjUzNjAw.html">http://v.youku.com/v_show/id_XMzE0NjUzNjAw.html</a></p> <p>C和弦与Am和弦的指法：</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image7.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb7.png" width="530" height="276"></a></p> <p>C和弦与Am和弦的切换：只有中指在换弦。</p> <p>P：大拇指</p> <p>I：食指</p> <p>M：中指</p> <p>A：无名指</p> <p>右手指法：5323 | 1323</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/79#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/79" itemprop="url">（转）腾讯微信技术总监周颢：一亿用户增长背后的架构秘密</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自网站：<a href="http://sd.csdn.net/a/20120515/2805581.html">http://sd.csdn.net/a/20120515/2805581.html</a> <p>周颢把微信的成功归结于腾讯式的<strong>“三位一体”策略：即产品精准、项目敏捷、技术支撑。</strong>微信的成功是在三个方面的结合比较好，能够超出绝大多数同行或对手，使得微信走到比较前的位置。所谓产品精准，通俗的讲就是在恰当的时机做了恰当的事，推出了重量级功能，在合适的时间以最符合大家需求的方式推出去。他认为在整个微信的成功中，产品精准占了很大一部分权重。 <p><strong>敏捷是一种态度 敏捷就是试错</strong> <p>微信研发团队里鼓励一种<strong>试错的信仰</strong>：<strong>他们坚信，在互联网开发里，如果能够有一个团队在更短的时间内尝试了更多机会(并能改进过来)，就能有(更多的)机会胜出。</strong>敏捷是一种态度，在软件开发过程中，项目管理者都会非常忌讳“变更”这个词，但是在微信的项目运作中是不可以的。<strong>因为微信必须要容忍说哪怕在发布前的十分钟，也要允许他变更。这是非常大的挑战，因为打破了所有传统项目开发的常识。所有人都说不可能做到的，但微信做到了。研发团队所做的一切都是要给产品决策者有最大的自由度，而这个决策正是微信能够胜出的关键。</strong> <p><strong>海量系统上的敏捷 无异于悬崖边的跳舞</strong> <p>敏捷有很多困境，如果做一个单机版程序，是可以做到很敏捷的，但是<strong>腾讯正在运作的是一个海量系统，有千万级用户同时在线，在一个单独的功能上每天有百亿级的访问，同时还要保证99.95%的可用性。在海量系统上应对项目开发会有很严谨的规范，都说要尽可能少的变化，因为90%-95%的错误都是在变更中产生的，如果系统一直不变更会获得非常高的稳定度，但是微信就是要在悬崖边跳舞。</strong>微信的研发团队要做一些事情，让敏捷开发变得更简单。 <p>如何做到这一切？周颢认为，首先，必须建立起一种<strong>狂热的技术信念，就是一定是可以做到的。</strong>然后，需要用一些稳固的技术(理念)来支撑，例如<strong>大系统小做</strong>、<strong>让一切可扩展</strong>、<strong>必须有基础组件</strong>、<strong>轻松上线</strong>(灰度、灰度、再灰度；精细监控；迅速响应)&#8230;等等来支撑。 <p><strong>四大法器</strong>：<strong>大系统小做、让一切可扩展、要有基础组件、轻松上线</strong> <ul> <li>大系统小做：当设计庞大系统的时候，应该尽量分割成更小的颗粒，使得项目之间的影响是最小的。  <li>一切可扩展：在高稳定度、高性能的系统中间，为了稳定性能把它设计成不变化的系统，但为了支持敏捷需要让一切的东西都要变得可以扩展。  <li>必须建立基础组件：要解决复杂问题的时候，需要将已有的经验固化下来，固化下来的东西会成为系统中的一部分。  <li>轻松上线：当做了变化并把它从开发环境中部署到现有的运营环境中去，在这个过程中，“灰度”这个词非常关键，就是在黑和白之间的选择，必须要变成一种小规模尝试，再逐步扩展到海量过程中的一个问题。<strong></strong> <p><strong></strong></p><p></li></ul> <p><strong>大系统小做——</strong><strong>仅仅把模块变得更为清晰，这在海量系统设计开发中是不够的，还需要在物理环境上进行分离部署，出现问题的时候可以快速发现，并且在最快的情况下解决掉。</strong> <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515074813_1.jpg" width="390" height="231"> <p>大系统小做 混搭模式 <p>将不同的应用逻辑物理分割独立出来，用户注册登录、LBS逻辑、摇一摇逻辑、漂流瓶逻辑、消息逻辑独立开来。把关键的逻辑混搭在一起，当所有的逻辑部署在同一个服务器上，确实也会带来很大敏捷上的好处，因为不需要额外的考虑部署和监控的问题。<strong>在整个微信的逻辑中，可能现在已经有上百种不同的逻辑，因为会在逻辑的分割上拆分成8-10种做分离部署。</strong> <p><strong>一切可扩展——网络协议可扩展、数据存储可扩展</strong> <p>扩展的关键点有两块。一个是网络协议需要扩展，当要升级一个新功能的时候，会有一些比较大的困难，所以所有协议设计都比较向前兼容，但是向前兼容还是不够的，因为网络协议设计本身有非常多的功能也会有比较大的字段，相关的代码可能会有数千行，这一块不能通过手写方式完成。可以通过XML描述，再通过工具自动生成所有的代码，这是微信获得快速开发的一个重要的点。 <p>另外一块就是在数据存储方面是必须可扩展的。在2005年绝大多数海量系统的设计都是采用固定字段的存储，但是在现代系统中会意识到这个问题，会采用KV或者TLV的方式，微信也做了不同的设计。 <p><strong>把复杂逻辑都固化下来，成为基础软件。</strong>在微信后台会有几种不同的基础组件。大致包括： <ul> <li>Svrkit——Client/Server自动代码生成框架:10分钟搭建内部服务器  <li>LogicServer——逻辑容器：随时添加新逻辑  <li>OssAgent——监控/统计框架：所见即所得的监控报表  <li>存储组件——屏蔽容灾/扩容等复杂问题</li></ul> <p><strong>灰度、灰度、再灰度</strong> <p>在变更后的部署方式上，微信在一些规则会限定不能一次把所有的逻辑变更上去，每一次变更一小点观察到每一个环节没有问题的时候，才能布局到全网上去。<strong>微信后台每一天可以支撑超过20个后台变更，在业界来说，通常做到5个已经是比较快了，但是微信可以做到快4倍。</strong> <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515075806_1.jpg" width="450" height="242"> <p>腾讯内部的上线系统 <p>而所谓<strong>灰度发布</strong>，是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面 来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。(在腾讯，灰度发布是最常采用的发布方式之一) <p><strong>孙子兵法：古之所谓善战者，胜于易胜者也</strong> <p>常识上，解决一个复杂问题的时候，会用高明的技巧解决复杂的问题，这个不是微信团队的目标，他们追求的要做到让所有问题很自然和简单的方式解决掉。<strong>在周颢看来，微信架构的技术复杂点在四个要点：协议、容灾、轻重、监控。</strong> <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515080024_1.jpg" width="450" height="345"> <p>微信架构 <ul> <li>协议。手机终端跟后台服务器之间的交互协议，这个协议的设计是整个系统的骨架，在这一点做好设计可以使得系统的复杂度大大降低。  <li>容灾。当系统出现了若干服务器或若干支架(宕机的时候)，仍然需要让系统尽可能的提供正常的服务。  <li>轻重。如何在系统架构中分布功能，在哪一个点实现哪一个功能，代表系统中间的功能配置。  <li>监控。为系统提供一个智能仪表盘。</li></ul> <p>在协议设计上，移动互联网和常规互联网有很大的区别。首先有CMWAP和CMNET的不同，在中国现在有相当多的手机用户使用WMWAP连接，还有就是在线和离线的概念，当QQ下线的时候叫离线，当你登录的时候叫在线。但是在移动互联网这两个概念比较模糊。从微信的设计中，不管在线还是离线系统表现都应该是一致的。还有一个是连接不稳定的问题，由于手机信号强弱的变化，当时信号很好，5秒钟走到信号不好的地区，连接就必须断掉。这个中间带来不稳定的因素为协议设计带来较大困难。此外就是资费敏感的问题，因为移动互联网是按照流量计费的，这个计费会使得在协议设计中如何最小化传输的问题。最后就是高延迟的问题。 <p>对此，业界标准的解决方案：Messaging And Presence Protocol：1)<span class="caps">XMPP</span>;2)<span class="caps">SIP</span>/SIMPLE。它的优点是简单，大量开源实现。而缺点同样明显：1)流量大：状态初始化；2)消息不可靠。 <p><strong>微信在系统中做了特殊设计，叫SYNC协议，是参考Activesyec来实现的。</strong>特点首先是基于状态同步的协议，假定说收发消息本身是状态同步的过程，假定终端和服务器状态已经被迟了，在服务器端收到最新的消息，当客户端、终端向服务器对接的时候，收取消息的过程实际上可以简单的归纳为状态同步的过程，收消息以及收取你好友状态更新都是相同的。在这样的模式之下，我们会也许会把交互的模式统一化，只需要推送一个消息到达的通知就可以了，终端收到这个通知就来做消息的同步。在这样的简化模式之下，安卓和塞班都可以得到统一。这样的系统本身的实现是更为复杂的，但是获得很多额外的好处。 <p>让剩下系统实现的部分更加简单，简化了交互模式，状态同步可以通过状态同步的差值获得最小的数据变更，通过增量的传输得到最小的数据传输量。通过这样的协议设计，微信可以确保消息是稳定到达的，而且是按序到达。引用一句俗话：比它炫的没它简单，比它简单的没它快，没谁比他更快，哪怕在GPRS下，微信也能把进度条轻易推到底。 <p><strong>追求完美设计的团队不能胜任海量服务</strong> <p>在容灾之前面向最坏的思考，如果系统真的挂了，需要做一些事情，首先是防止雪崩，避免蝴蝶效应。<strong>如果关注春节订火车票就知道了，用户的请求量会因为系统服务不了而不断的重试，意味着发生雪崩的时候，系统可能会承载原先3-10倍的流量，使得所有的事情更加恶化。所以微信有很多“放雪”功能的设计。第二个词是柔性可用，在任何的系统中不要追求完美设计，追求完美设计的是团队是不能胜任海量服务的。如果在一个系统出现问题的时候，这个系统就挂了，那么这是一个不好的设计，最好的做法是提供0-1中间的选择。</strong>举一个例子，当一个用户向另外一个用户发消息的时候，可能会通过一个垃圾信息过滤的检测，如果垃圾信息过滤这个模块突然挂掉了，这个消息难道就不能达到了吗？在这样的情况下，要忽略掉这个错误，使得消息正常达到对方。要精确定位出哪一个环节是最为重要的，把不是重要的错误尽可能的忽略掉。当不能做到完美的时候，尽可能为用户提供服务。另外一个重要方面叫做“保护点前置”，最前的一个点就是终端，在手机终端上蕴埋更多的保护点，这样会为用户系统赢得更大的处理空间。如果终端具备这样的能力，会获得更大的反应空间。 <p>周颢介绍了在微信上具体容灾设计的做法。在所有的容灾中存储层的容灾是最难的，一个系统的设计分为三层：接入层、逻辑层、存储层。接入层和逻辑层的容灾都有比较成熟的方案。逻辑层的容灾相对来说比较简单，尽量不要有状态的设计，比如说当你做上一个请求的时候，会保持一些状态，要使得下一个请求发到下一个服务器。如果任何一个请求之间互相不关联的话，这个就是无状态的设计，只要做到这一点逻辑层的容灾可以随意的切换。在回到存储层本身的容灾设计上，相对来说困难一些，但是<strong>微信研发团队采用了一些技巧，叫分而治之，分离业务场景，寻求简单的设计，并不会寻求大而同一的解决方案，因为这样会使得系统的复杂度大幅度上升，而微信会尽可能把产品拆细，寻求简化的设计。</strong> <p>首先是主备容灾，这是最常见的方案。在有一些业务场景中是可以容忍最终一致性的，比如账号系统的设计，每天写入账号系统的请求是非常少的，但是访问的请求非常多，这个差异可能会达到数万倍的规模，在这样的场景下，微信会在账号系统中采用简化的方案，也可以获得比较大的稳定度。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515080736_1.jpg" width="360" height="240"> <p>SET模型＋双写 <p>第二种容灾的模式叫双写，两台Master的机器，当一台机故障的时候，另外一台机还是可以接收到写请求，当两台机交错启动的时候，会得到数据的丢失。但是有一些场景是可以容忍轻度数据丢失的，比如说会有一个存储专门记录用户终端的类型，比如说安卓还是塞班以及他们使用终端的微信版本是什么，这样的数据是可以容忍轻度数据丢失的，因为偶尔有一些丢失的话，下一次访问会把这些数据带上来，会尽快的修复所有的数据。双写也是非常简单的模式。 <p>微信的研发团队做了一个叫Simple Quorum的机制，在微信的后台中，同步协议有一个很重要的基石叫序列发生器，这样的一个序列发生器需要有极高的稳定度。首先可以看到序列号有一个特点永远是递增的，用递增方式往前推进的时候，最大的序列号就是最新的系列号。有一个毕业才加入广研的毕业生想到一个绝佳的方案，按SET分布，从2G减到200K。 <p><strong>前轻后重 功能点后移</strong> <p>周颢还谈到了轻重的概念。这个概念的提出主要是从终端本身的一些困境所带来的。首先在终端上需要表现最多的一个产品的逻辑，逻辑非常复杂，变更的成本也非常高，当需要修复的时候必须发布一个新版本，这个新版必须由自己下载才能完成，下载的成本非常高。在这样的前提下，如果手机终端产生了任何变化的时候，如果这个变化有非常大的问题就会有极大的困境，所以需要在每一个发布之前做一些充分的数据，确保不会发生致命问题。如果一旦出现致命问题难以修复，需要把关键的点从终端移到后台实现，把功能点后移，来充分发挥后台快速变更的能力。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515081038_1.jpg" width="450" height="278"> <p>接入优化：从GSLB到IP重定向 <p>在接入层的优化，速度很重要的因素，是不是能够就近接入一个最优的节点，比如说移动用户最好接入移动的节点，海外的用户可能需要寻找更佳的路由，有的时候可能无法自动做到这一点，一点是在终端上做测速，微信会通过在后台IP逆向的能力，通过后台指挥微信终端联网的能力，寻找最优的接入点。上图就是每分钟收到同一项指令曲线的报表。 <p><strong>如何解决“偷流量”的问题</strong>——当国内类微信类产品发布的时候出现一个大的问题就是“偷流量”，当用户在某一些逻辑下进行一个死循环，不断访问某一些数据，这样的死循环是非常可怕的，如果在用户不知觉的情况之下，可能会在一个小时之内偷到数10兆甚至数百兆的流量。有非常多业内的同行都需要花大量的精力解决这个问题，微信研发团队用了非常强大的方式解决它。通过在后台建立起严厉的监控系统，对每一个用户的行为做一个监控，当发现异常的时候，后台会给终端发出指令，使得微信终端在一段时间无法联网，但是可以保证用户流量不会白白的使用掉。 <p><strong>功能适配的例子——</strong>第一期微信版本发布的时候，当时没有群聊的功能，第二版发布的时候做了这个功能。当时有两个选择，对于早期版本的用户，因为不支持群聊，就无法享用到这个功能，但是微信希望提供更好的选择，想让早期不支持群聊的版本，也可以被拉到一个群里面收消息、发消息，通过后台功能的适配也能做到这个事情。 <p><strong>分而治之 把监控嵌入基础框架</strong> <p>对于一个海量系统来说，一个精密的仪表盘非常重要。监控是非常痛苦的，对于这样一个系统来说，每小时会产生数百G的监控日志。微信希望在1分钟之内监控的数据就能够显示在报表上，因为只有这样的精准和实时度才能够赢得处理故障的时间。<strong>微信会做关联统计，通过摇一摇加了好友，他们活跃度如何，过了一段时间他们的活跃度变化情况又是如何。这种需求是需要通过大量日志的关联统计来获得的。研发团队也花了一段时间来理解这个问题，发现了中间一个重要的经验叫做“鱼和熊掌不能兼得”。</strong> <p>为了让监控数值更敏感，需要把监控细化再细化，上面数据表示每一栏子系统的数据，下面这个是按微信版本号来划分的，这里的数据项是非常多。 <p>微信还需要采集一些异常的点，如果有异常的话会发布紧急的版本，尽可能快的替换它。对收发消息延时做的监控，比如说0—1秒端到端的速度，会对不同的区段做一些统计，当某一个环节出现异常的时候，通常会在中间的延时上体现出来。有一个很重要的点叫自动报警，现在有数千项的数据，不可能每一项都靠人工去看的，必须要跟自动报警相关联，微信有一些智能的算法，是不是在正常的范围内，跟历史的数值进行对比，如果有异常的话，会通过短信、邮件还有微信本身来发出报警信息。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515081321_1.jpg" width="450" height="189"> <p>把监控嵌入基础框架 <p>微信会把监控嵌入到基础框架里面去，因为并不是每一个人都会意识到在需要的地方嵌入一个监控点，所以在基础框架本身内置很重要的监控点，比如说这个表上的栏目，非常多的栏目大概会有数百项的栏目，都不需要程序员自己去写，当用基础组件搭建一个系统的时候，就可以直接观测系统数据。 <p>在谈到微信未来的技术挑战时，周颢首先希望能够让微信成为可用性99.99%的系统；设计出面向现在10倍容量的系统以及完全的IDC容灾。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515081630_1.jpg" width="450" height="537"> <p>网上盛传的凌晨两点，腾讯大厦那多层大片大片的灯光和楼下那长长的出租车队伍说明了一切。引用一句话做结尾，可怕的不是微信，真正可怕的是，比你领先比你更有天赋的团队比你更努力。 <p>附录：腾讯微信技术总监周颢演讲<a href="http://download.csdn.net/detail/java060515/4302512">PPT下载</a></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/77#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/77" itemprop="url">灰度发布</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自：<a href="http://sd.csdn.net/a/20120515/2805581.html">http://sd.csdn.net/a/20120515/2805581.html</a></p> <p>所谓<strong>灰度发布</strong>，是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面 来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。(在腾讯，灰度发布是最常采用的发布方式之一)</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/73#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/73" itemprop="url">20120811- 腾讯iron敏捷开发讲座</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><b>Scrum</b>是一种迭代式增量软件开发过程，通常用于<a href="http://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">敏捷软件开发</a>。</p> <p><strong>Scrum中的主要角色</strong>包括： <ol> <li>&#8216;Scrum Master&#8217; 是Scrum教练和团队带头人，确保团队合理的运作Scrum，并帮助团队移除实施中的障碍；  <li><b>产品负责人</b>(Product Owner)，确定产品的方向和愿景，定义产品发布的内容、优先级及交付时间，为产品ROI负责；  <li><b>开发团队</b>(Team)，一个跨职能的小团队，人数5-9人，团队拥有交付可用软件需要的各种技能。(key words:7,cross)</li><p></ol> <p>在每一次冲刺（一个15到30天的周期，其长度由开发团队决定）当中，开发团队创建可用的（可以随时推出）软件的一个增量。每一个冲刺所要实现的功能来自产品订单（product backlog）。产品订单是按照优先级排列的要完成的工作的概要的需求，哪些订单项会被加入一次冲刺将由冲刺计划会议决定。 在会议中，产品负责人告诉开发团队他需要完成产品订单中的哪些订单项。开发团队决定在下一次冲刺中他们能够承诺完成多少订单项。<sup><a href="http://zh.wikipedia.org/wiki/Scrum#cite_note-schwaber-3"><sup class="footnote" id="fnr4"><a href="#fn4">4</a></sup></a></sup> 在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog），这意味着在一个冲刺中需求是被冻结的。(key word: product backlog(what)-&gt;sprint backlog(how))</p> <p><img alt="File:Scrum process zh.svg" src="http://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Scrum_process_zh.svg/800px-Scrum_process_zh.svg.png"></p> <h4>Scrum会议</h4> <p>在冲刺中，每一天都会举行项目状况会议，被称为“scrum”或“每日站立会议”。每日站立会议有一些具体的指导原则： <ul> <li>会议准时开始。对于迟到者团队常常会制定惩罚措施（例如罚款，做俯卧撑，在脖子上挂橡胶鸡玩具）  <li>欢迎所有人参加，但只有&quot;猪&quot;可以发言。  <li>不论团队规模大小，会议被限制在15分钟。  <li>所有出席者都应站立。（有助于保持会议简短）  <li>会议应在固定地点和每天的同一时间举行。</li></ul> <p>在会议上，每个团队成员需要回答三个问题：<sup><a href="http://zh.wikipedia.org/wiki/Scrum#cite_note-schwaber-3"><sup class="footnote" id="fnr4"><a href="#fn4">4</a></sup></a></sup> <ul> <li>今天你完成了那些工作？  <li>明天你打算做什么？  <li>完成你的目标是否存在什么障碍？（Scrum主管需要记下这些障碍）</li></ul> <p><strong><span class="caps">REVIEW</span></strong></p> <p>每一个冲刺完成后，都会举行一次冲刺回顾会议，在会议上所有团队成员都要反思这个冲刺。举行冲刺回顾会议是为了进行持续过程改进。会议的时间限制在4小时。 <p>Scrum提倡所有团队成员坐在一起工作，进行口头交流，以及强调项目有关的规范（disciplines），这些有助于创造自我组织的团队。 <p>&nbsp; <p><strong>文档:</strong> <h5>产品订单</h5> <p>产品订单（<b>product backlog</b>）是整个项目的概要文档。产品订单包括所有所需特性的粗略的描述。产品订单是关于将要创建的什么产品。产品订单是开放的，每个人都可以编辑。产品订单包括粗略的估算，通常以天为单位。估算将帮助产品负责人衡量时间表和优先级（例如，如果&quot;增加拼写检查&quot;特性的估计需要花3天或3个月，将影响产品负责人对该特性的渴望）。 <h5>冲刺订单</h5> <p>冲刺订单（<b>sprint backlog</b>）是大大细化了的文档，包含团队如何实现下一个冲刺的需求的信息。任务被分解为以小时为单位，没有任务可以超过16个小时。如果一个任务超过16个小时，那么它就应该被进一步分解。冲刺订单上的任务不会被分派，而是由团队成员签名认领他们喜爱的任务。 <h5>燃尽图</h5> <p><a href="http://zh.wikipedia.org/w/index.php?title=%E7%87%83%E5%B0%BD%E5%9B%BE&amp;action=edit&amp;redlink=1">燃尽图</a>（burn down chart）是一个公开展示的图表，显示当前冲刺中未完成的任务数目，或在冲刺订单上未完成的订单项的数目。不要把燃尽图与<a href="http://zh.wikipedia.org/wiki/%E6%8C%A3%E5%80%BC%E7%AE%A1%E7%90%86">挣值图</a>相混淆。A burn down chart could be flat for most of the period covered by a sprint and yet the project could still be on schedule. <p><strong>价值观：</strong> <ul> <li><b>人和交互</b> 重于过程和工具。  <li><b>可以工作的软件</b> 重于求全责备的文档。  <li><b>客户协作</b>重于合同谈判。  <li><b>随时应对变化</b>重于循规蹈矩。</li></ul> <p>其中位于右边的内容虽然也有其价值，但是左边的内容最为重要。</p></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/71#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/71" itemprop="url">Typedef Struct的前置声明</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>参照网站：<a href="http://dreamume.blog.163.com/blog/static/184923719201236115353586/">http://dreamume.blog.163.com/blog/static/184923719201236115353586/</a></p> <p>如果有typedef struct，则需要把这句拷贝作为前置声明。<br>有些typedef struct语句可能在某些库头文件中，很难找，如果遇到这种情况，可以假定一个错误的定义，然后通过gcc的编译提示找到该句。<br>例如：<br>typedef struct STruncData SPlainData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; STruncData是随意写的 */<br>则gcc编译会提示找到两处不同的SPainData定义，这样就找出了正确的那个，拷贝出来直接使用即可。 <p><strong>注：没有测试过，待验证。</strong></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/69#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/69" itemprop="url">正确使用#include和前置声明(forward Declaration)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自网站：<a href="http://blog.csdn.net/SpriteLW/article/details/965702">http://blog.csdn.net/SpriteLW/article/details/965702</a></p> <p>差不多一年时间没用过C++写过程序了,由于工作的需要,我又回到了C++的阵形。在工作的过程中遇到了很多麻烦，当我往工程里加一个类，而且那个类又与工程里的类相关，如有那个类型的成员变量。情况如下 <p>//////A.h/////////// <p>class A <p>{ <p>&#8230;&#8230;. <p>}; <p>////////B.h////////// <p>class B:A <p>{ <p>&#8230;. <p>A member; <p>} <p>结果，编译就会出错，说找不到类形A。解决的办法是在B.h里#include “A.h”。但是有时候不用#include “A.h”，只要在classB:A前加class A;就可以了。更严重的是不但要#include “A.h”，还要class A;。 <p>起初觉得没问题，因为这样搞来搞去总会编译通过的，而且不会让程序变大，因为有#ifndef&#8230;#endif和#pragma once控制。直到有一次，我需要那些常量放到一个文件中“const.h”，然后include到其它需要它的类中，结果怎么也编译不成功（因为文件多了，而且每个文件都这样互相include，把我也蒙了） <p>直到今天终于从《Effective C++》里找到原理。现向大家分享一下，首先我以下面这个类结构作例子。（先不管我为什么不加一个Woman，为什么Man就有child，我只是作例子解说，绝没有性别歧视。 <p><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/SpriteLW/gif_1.gif"> <p>代码如下： <p>////////////main.h////////////// <p>#include &#8220;stdafx.h&#8221; <p>#include &#8220;man.h&#8221; <p>int main(){ <p>&nbsp;&nbsp;&nbsp; Man m; <p>return 0; <p>} <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>}; <p>////////Person.cpp/////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./person.h&#8221; <p>Person::Person(void){ <p>} <p>Person::~Person(void){ <p>} <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////////Man.cpp////////////// <p>#include &#8220;StdAfx.h&#8221; <p>#include &#8220;./man.h&#8221; <p>Man::Man(void){ <p>} <p>Man::~Man(void){ <p>} <p>上述代码，编译运行一切正常。现在我作以下修改： <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉 <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>error C2504: “Person” : 未定义基类 <p>error C2504: “Person” : 未定义基类 <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man:public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person <strong>child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //改为指针 <p>}; <p>error C2504: “Person” : 未定义基类 <p>编译通过 <p>要讲解上面的代码还要一些预备知备，看下面代码： <p>int main() <p>{ <p>int x; <p>&nbsp;&nbsp;&nbsp; Person p;//用C++时编译不通过; <p>} <p>当编译器看到x定义式时，它们知道必须配置足够的空间以放置一个int。没问题，每个编译器都知道int有多大。然而当编译器看到p的定义式时，虽然它们也知道必须配置足够空间以放置一个Person，但一个Person对象有多大呢？编译器获得这项信息的唯一办法就是询问class定义式。然而class的定义式可以合法地不列出实现细节（如： <p>只写出class Person;）那么编译器又如何知道该配置多少空间呢？ <p>对Java等语言对此问题的解法是，当程序定义出一个对象时，只配置足够空间给一个“指向该对象的指针”使用，如<br>public Person; <p>public static void main(String[] args) <p>{ <p>&nbsp;&nbsp;&nbsp; Person p; <p>} <p>对于C++就如下那样： <p>class Person; <p>int main() <p>{ <p>&nbsp;&nbsp;&nbsp; Person *p;//编译器当要配置一个指针大小的空间的指针给p就可以了。 <p>//Person &amp;p2; 这个理论上也可以，但references object必须“言之有物” <p>return 0; <p>} <p>看回刚才那段代码为什么“Person p;//用C++时编译不通过;”呢？因为它要调用Person constructor。那就是Person的实现细节。 <p>现在可以解说上面的表格了，我的目的是 <strong>去掉#include <strong>“</strong><strong>Person.h</strong><strong>”</strong>并加入class Person; 所以要做有：</strong> <p>1. 将Person child改为Person *child。因为child也是Man的成员，Man的大小与Child相关，而child不是内部类型，它的大小编译器不知道。 <p>2. 将:public Person去掉。因为Man继承Person，所以编译器也要知道Person是怎样实现的，那样才能构造出正确的Man来（为了编译成功，我忍痛割爱了）。 <p>同时我也要对原码作一下解释： <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221; <p>class Man : public Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person child; <p>}; <p>这里#include “person.h”不但包含了Person的定义，也包含了Person的实现细节，所以是编译成功的。 <p><strong>结论</strong>： <p>1. 当不需要调用类的实现时，包括constructor，copy constructor,assignment operator,member function，甚至是address-of operator时，就不用#include，只要forward declaration就可以了。 <p>2. 当要用到类的上面那些“方法”时，就要#include <p><strong>扩充</strong>： <p>为了加深认识，我分享遇到的另一情况。 <p>////////////Person.h///////////// <p>#pragma once <p>class Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Person(void); <p>&nbsp;&nbsp;&nbsp; ~Person(void); <p>virtual void addChild(Person p) = 0;//将Person变为抽象类 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>//#include &#8220;person.h&#8221;&nbsp;&nbsp; //去掉 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person p);//相应地在Man.cpp中加上这个空函数 <p>}; <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person *p);//将形参变为Person</strong> <p>}; <p>error C2259: “Person” : 不能实例化抽象类 <p>编译成功 <p>/////////Man.h/////////// <p>#pragma once <p>#include &#8220;person.h&#8221;&nbsp;&nbsp;&nbsp; //加回来 <p>class Person;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加不加入也没所谓 <p>class Man&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //去掉:Person <p>{ <p>public: <p>&nbsp;&nbsp;&nbsp; Man(void); <p>&nbsp;&nbsp;&nbsp; ~Man(void); <p>private: <p>&nbsp;&nbsp;&nbsp; Person *child; <p>void addChild(Person &amp;p);//将形参变为Person&amp; <p>}; <p>编译成功 <p>为什么出现不能实例化抽象类？我并没有实例化过它。 <p>这是参数的传递问题。当一个变量传给函数时，我们说是实参传给形参（pass-by-value），形参是通过copy constructor建立的，所以就是实例化了一个抽象类。而pass-by-reference和传指针就没问题了。（全文完） <p>参考资料： <p>候捷：《Effective C++》
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00+08:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/67#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/67" itemprop="url">头文件中循环引用</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自网站：<a href="http://hi.baidu.com/shilyx/blog/item/c1e3f7f277e29811b17ec5f2.html">http://hi.baidu.com/shilyx/blog/item/c1e3f7f277e29811b17ec5f2.html</a></p> <p><strong>一、类嵌套的疑问</strong> <p>C++头文件重复包含实在是一个令人头痛的问题，前一段时间在做一个简单的数据结构演示程序的时候，不只一次的遇到这种问题。假设我们有两个类A和B，分别定义在各自的有文件A.h和B.h中，但是在A中要用到B，B中也要用到A，但是这样的写法当然是错误的：<br>class B; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B b;<br>}; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A a;<br>};<br>因为在A对象中要开辟一块属于B的空间，而B中又有A的空间，是一个逻辑错误，无法实现的。在这里我们只需要把其中的一个A类中的B类型成员改成指针形式就可以避免这个无限延伸的怪圈了。为什么要更改A而不是B？因为就算你在B中做了类似的动作，也仍然会编译错误，表面上这仅仅上一个先后顺序的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么会这样呢？因为C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据的类型的大小。在预先声明语句class B;之后，编译器已经知道B是一个类，但是其中的数据却是未知的，因此B类型的大小也不知道。这样就造成了编译失败，VC++6.0下会得到如下编译错误：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error C2079: &#8216;b&#8217; uses undefined class &#8216;B&#8217;<br>将A中的b更改为B指针类型之后，由于在特定的平台上，指针所占的空间是一定的（在Win32平台上是4字节），这样可以通过编译。 <p><strong>二、不同头文件中的类的嵌套</strong> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在实际编程中，不同的类一般是放在不同的相互独立的头文件中的，这样两个类在相互引用时又会有不一样的问题。重复编译是问题出现的根本原因。为了保证头文件仅被编译一次，在C++中常用的办法是使用条件编译命令。在头文件中我们常常会看到以下语句段（以VC++6.0自动生成的头文件为例）： <p>#if !defined(AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_)<br>#define AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //很多语句……<br>#endif <p>其中首句#if !defined也经常做#ifndef，作用相同。意思是如果没有定义过这个宏，那么就定义它，然后执行直到#endif的所有语句。如果下次在与要这段代码，由于已经定义了那个宏，因此重复的代码不会被再次执行。这实在是一个巧妙而高效的办法。在高版本的VC++上，还可以使用这个命令来代替以上的所有：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #pragma once<br>它的意思是，本文件内的代码只被使用一次。 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是不要以为使用了这种机制就全部搞定了，比如在以下的代码中： <p>//文件A.h中的代码<br>#pragma once <p>#include &#8220;B.h&#8221; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B* b;<br>}; <p>//文件B.h中的代码<br>#pragma once <p>#include &#8220;A.h&#8221; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A* a;<br>}; <p>这里两者都使用了指针成员，因此嵌套本身不会有什么问题，在主函数前面使用#include &#8220;A.h&#8221;之后，主要编译错误如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error C2501: &#8216;A&#8217; : missing storage-class or type specifiers<br>仍然是类型不能找到的错误。其实这里仍然需要前置声明。分别添加前置声明之后，可以成功编译了。代码形式如下： <p>//文件A.h中的代码<br>#pragma once <p>#include &#8220;B.h&#8221; <p>class B; <p>class A<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B* b;<br>}; <p>//文件B.h中的代码<br>#pragma once <p>#include &#8220;A.h&#8221; <p>class B; <p>class B<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A* a;<br>}; <p>这样至少可以说明，头文件包含代替不了前置声明。有的时候只能依靠前置声明来解决问题。我们还要思考一下，有了前置声明的时候头文件包含还是必要的吗？我们尝试去掉A.h和B.h中的#include行，发现没有出现新的错误。那么究竟什么时候需要前置声明，什么时候需要头文件包含呢？ <p><strong>三、两点原则</strong> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 头文件包含其实是一想很烦琐的工作，不但我们看着累，编译器编译的时候也很累，再加上头文件中常常出现的宏定义。感觉各种宏定义的展开是非常耗时间的，远不如自定义函数来得速度。我仅就不同头文件、源文件间的句则结构问题提出两点原则，仅供参考： <p>第一个原则应该是，如果可以不包含头文件，那就不要包含了。这时候前置声明可以解决问题。如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知。 <p>第二个原则应该是，尽量在CPP文件中包含头文件，而非在头文件中。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类B的前置声明并便宜成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件)。</p>
		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/6/" class="prev">Prev</a>
    
    
        <a href="/blog/page/8/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Mr.Liao


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	

<script type="text/javascript">
      var disqus_shortname = 'minlh';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










</body>
</html>
