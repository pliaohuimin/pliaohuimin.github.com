
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Min's Lounger</title>
	<meta name="author" content="Mr.Liao">

	
	<meta name="description" content="Nov 30th, 2012 Comments x86_64下编译php出现错误(Try Adding &#8211;with-zlib-)解决(转） 下面文字转自：http://blog.chinaunix.net/uid-6984-id-2071531.html &nbsp; config. &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Min's Lounger" type="application/atom+xml">
	
	<link rel="canonical" href="http://pliaohuimin.github.io/blog/page/6/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("pliaohuimin@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>
<h1><a href="/">Min's Lounger</a></h1>
<p class="subtitle">All Life Sucks,all we can do is let it suck less</p>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/categories/travelling">Travelling</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:pliaohuimin@gmail.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-11-30T00:00:00-08:00" data-updated="true" itemprop="datePublished">Nov 30<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/126#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/126" itemprop="url">x86_64下编译php出现错误(Try Adding &#8211;with-zlib-)解决(转）</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>下面文字转自：<a title="http://blog.chinaunix.net/uid-6984-id-2071531.html" href="http://blog.chinaunix.net/uid-6984-id-2071531.html">http://blog.chinaunix.net/uid-6984-id-2071531.html</a></p> <p>&nbsp;</p> <p>config.log中同时有/usr/bin/ld: cannot find <del>lmysqlclient错误 <p>系统版本如下<br>[root@opencms php-5.2.6]# uname -a<br>Linux opencms 2.6.18-92.el5 #1 <span class="caps">SMP</span> Tue Apr 29 13:16:15 <span class="caps">EDT</span> 2008 x86_64 x86_64 x86_64 <span class="caps">GNU</span>/Linux <p>安装php-5.2.6的时候，编译选项如下：<br>[root@opencms php-5.2.6]#./configure &quot;</del>-prefix=/usr/local/php&quot; &#8220;&#8212;with-apxs2=/usr/local/apache/bin/apxs&#8221; &#8220;&#8212;with-config-file-path=/usr/local/php/etc&#8221; &#8220;&#8212;with-mysql&#8221; <p>报以下错误 <p>configure: error: Try adding &#8212;with-zlib-dir=  <dir>. Please check config.log for more information.</dir> <p>查看config.log，发现里面有下面提示： <p>configure:60044: gcc -o conftest -I/usr/include -g -O2 -Wl,-rpath,/usr/lib/mysql -L/usr/lib/mysql -L/usr/lib conftest.c -lmysqlclient -lz -l resolv -lm -ldl -lnsl -lxml2 -lz -lm -lxml2 -lz -lm 1&gt;&amp;5 /usr/bin/ld: cannot find -lmysqlclient collect2: ld returned 1 exit status configure: failed program was: #line 60033 &#8220;configure&#8221; #include &#8220;confdefs.h&#8221; /* Override any gcc2 internal prototype to avoid an error. <strong>/ /</strong> We use char because int might match the return type of a gcc2 builtin and then its argument prototype would still apply. <strong>/ char mysql_errno(); int main() { mysql_errno() ; return 0; } <p>由于本系统时x86_64的，在/usr下有lib和lib64两个目录，现在提示是在/usr/lib/mysql下找mysql</strong>文件，感觉不太对劲，于是<br>[root@opencms php-5.2.6]# cd /usr/lib<br>[root@opencms lib]# mv mysql/ mysql.bak/<br>[root@opencms lib]# ln -s /usr/lib64/mysql /usr/lib/mysql<br>重新编译php，一些正常。 <p>不知道为什么会在两个目录下都出现mysql目录，用以下命令查看的时候发现了问题所在<br>[root@opencms lib]# rpm -qa | grep mysql<br>mysql-5.0.45-7.el5<br>libdbi-dbd-mysql-0.8.1a-1.2.2<br>mysql-devel-5.0.45-7.el5<br>mysql-5.0.45-7.el5<br>mysql-server-5.0.45-7.el5<br>mysql-connector-odbc-3.51.12-2.2<br>原来是同一个package出现了两次，版本也都是一样的，我估计是安装系统的人把32位和64位的mysql都安装了一遍。。。 <p>于是执行卸载<br>[root@opencms lib]# rpm -e mysql<br>error: &#8220;mysql&#8221; specifies multiple packages<br>卸载不掉 <p>通过rpm &#8212;help发现–allmatches应该可以解决这个问题：<br>–allmatches<br>Remove all versions of the package which match PACKAGE_NAME. Normally an error is issued if PACKAGE_NAME matches<br>multiple packages.<br>rpm -e &#8212;allmatches mysql-5.0.45-7.el5<br>卸载的时候又出现包依赖，最后使用<br>rpm -e -nodeps &#8212;allmatches mysql-5.0.45-7.el5<br>全部卸载完毕后重新安装x86_64的mysql，就只在/usr/lib64下出现mysql目录了。<br>可这时问题又出现了，报以下错误：<br>configure: error: Cannot find libmysqlclient under /usr.<br>Note that the MySQL client library is not bundled anymore!<br>应该还是php编译的时候默认去找/usr/lib/mysql这个目录，重复刚才的步骤：<br>[root@opencms lib]# ln -s /usr/lib64/mysql /usr/lib/mysql<br>重新编译php，问题解决！</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-11-25T00:00:00-08:00" data-updated="true" itemprop="datePublished">Nov 25<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/124#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/124" itemprop="url">Foobar播放ape格式音乐</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>之前安装的foobar2000 v1.1.7不支持ape格式的音乐播放。发现需要安装插件（components）才行。</p> <p>到官网<a title="http://www.foobar2000.org/components/view/foo_input_monkey" href="http://www.foobar2000.org/components/view/foo_input_monkey">http://www.foobar2000.org/components/view/foo_input_monkey</a>下载相关插件：foo_input_monkey.fb2k-component。</p> <p>将下载后的文件的文件名后缀改成rar格式，直接解压，可得到foo_input_monkey.dll文件。将这个文件拷到foobar2000安装目录的components目录下。</p> <p>打开foobar2000，选择file-&gt;preference，弹出面板后后选择components，点击右下角的install，到foobar2000安装目录的components目录下选中foo_input_monkey.dll，点击打开。</p> <p>再点击右下角的apply。会弹出是否重启foobar的面板，点击是重启后即可直接播放ape文件了。</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-11-20T00:00:00-08:00" data-updated="true" itemprop="datePublished">Nov 20<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/travelling/'>Travelling</a>


</div>
		
			<span class="comments"><a href="/blogs/122#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/122" itemprop="url">LIST</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>NO1:黄埔古港</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-10-25T00:00:00-07:00" data-updated="true" itemprop="datePublished">Oct 25<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/travelling/'>Travelling</a>


</div>
		
			<span class="comments"><a href="/blogs/113#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/113" itemprop="url">旅行摄影（穷游版）</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>来自：<a href="http://www.qyer.com/">http://www.qyer.com/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 穷游网/穷游锦囊/旅行摄影</p> <p>&nbsp;</p> <ol>
	<li>光圈和景深 <p>&nbsp;</p> <p><a href="http://www.minlh.tk/uploads/2012/10/e8d4ce2da4da.jpg"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="光圈与景深描述" border="0" alt="光圈与景深描述" src="http://www.minlh.tk/uploads/2012/10/thumb.jpg" width="569" height="264"></a></p> <p><a href="http://www.minlh.tk/uploads/2012/10/2e977ee0849d.jpg"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="光圈与景深图示" border="0" alt="光圈与景深图示" src="http://www.minlh.tk/uploads/2012/10/thumb1.jpg" width="569" height="296"></a></p> # 广角和长焦 <p><a href="http://www.minlh.tk/uploads/2012/10/e5033dacd22d.jpg"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="广角和长焦" border="0" alt="广角和长焦" src="http://www.minlh.tk/uploads/2012/10/thumb2.jpg" width="569" height="161"></a></p> <p>&nbsp;</p> # 快门和ISO <p><a href="http://www.minlh.tk/uploads/2012/10/ISO.jpg"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="快门和ISO" border="0" alt="快门和ISO" src="http://www.minlh.tk/uploads/2012/10/ISO_thumb.jpg" width="569" height="329"></a></p></li>
</ol>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-09-24T00:00:00-07:00" data-updated="true" itemprop="datePublished">Sep 24<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/107#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/107" itemprop="url">栈区，堆区，全局区，文字常量区，程序代码区 详解</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自网站：<a href="http://blog.csdn.net/happylife1527/article/details/7879370">http://blog.csdn.net/happylife1527/article/details/7879370</a></p> <p>&nbsp;</p> <p>一个由C/C++编译的程序占用的内存分为以下几个部分 <p>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 <p>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 <p>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 &#8211; 程序结束后有系统释放 <p>4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 <p>5、程序代码区—存放函数体的二进制代码。 <p>二、例子程序 <p>这是一个前辈写的，非常详细 <p>//main.cpp <p>int a = 0; 全局初始化区 <p>char *p1; 全局未初始化区 <p>main() <p>{ <p>int b; 栈 <p>char s[] = &#8220;abc&#8221;; 栈 <p>char *p2; 栈 <p>char *p3 = &#8220;123456&#8221;; 123456在常量区，p3在栈上。 <p>static int c =0； 全局（静态）初始化区 <p>p1 = (char *)malloc(10); <p>p2 = (char *)malloc(20); <p>分配得来得10和20字节的区域就在堆区。 <p>strcpy(p1, &#8220;123456&#8221;); 123456放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。 <p>} <p>二、堆和栈的理论知识 <p>2.1申请方式 <p>stack: <p>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 <p>heap: <p>需要程序员自己申请，并指明大小，在c中malloc函数 <p>如p1 = (char *)malloc(10); <p>在C++中用new运算符 <p>如p2 = (char *)malloc(10); <p>但是注意p1、p2本身是在栈中的。 <p>2.2 <p>申请后系统的响应 <p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 <p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 <p>2.3申请大小的限制 <p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 <p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 <p>2.4申请效率的比较： <p>栈由系统自动分配，速度较快。但程序员是无法控制的。 <p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. <p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 <p>2.5堆和栈中的存储内容 <p>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 <p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 <p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 <p>2.6存取效率的比较 <p>char s1[] = &#8220;aaaaaaaaaaaaaaa&#8221;; <p>char *s2 = &#8220;bbbbbbbbbbbbbbbbb&#8221;; <p>aaaaaaaaaaa是在运行时刻赋值的； <p>而bbbbbbbbbbb是在编译时就确定的； <p>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 <p>比如： <p>#include <p>void main() <p>{ <p>char a = 1; <p>char c[] = &#8220;1234567890&#8221;; <p>char *p =&#8220;1234567890&#8221;; <p>a = c<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>; <p>a = p<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>; <p>return; <p>} <p>对应的汇编代码 <p>10: a = c<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>; <p>00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] <p>0040106A 88 4D FC mov byte ptr [ebp-4],cl <p>11: a = p<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>; <p>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] <p>00401070 8A 42 01 mov al,byte ptr [edx+1] <p>00401073 88 45 FC mov byte ptr [ebp-4],al <p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。 <p>2.7小结： <p>堆和栈的区别可以用如下的比喻来看出： <p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 <p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 <p>1、内存分配方面： <p>&nbsp;&nbsp;&nbsp; 堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。 <p>&nbsp;&nbsp;&nbsp; 栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 <p>2、申请方式方面： <p>&nbsp;&nbsp;&nbsp; 堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 <p>&nbsp;&nbsp;&nbsp; 栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 <p>3、系统响应方面： <p>&nbsp;&nbsp;&nbsp; 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 <p>&nbsp;&nbsp;&nbsp; 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 <p>4、大小限制方面： <p>堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 <p>&nbsp;&nbsp;&nbsp; 栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 <p>5、效率方面： <p>&nbsp;&nbsp;&nbsp; 堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 <p>&nbsp;&nbsp;&nbsp; 栈：由系统自动分配，速度较快。但程序员是无法控制的。 <p>6、存放内容方面： <p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 <p>栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 <p>7、存取效率方面： <p>堆：char *s1 = &#8220;Hellow Word&#8221;；是在编译时就确定的； <p>栈：char s1[] = &#8220;Hellow Word&#8221;； 是在运行时赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。 <p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-21T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 21<span>st</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/92#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/92" itemprop="url">Vim缩进设置</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>参考网站：<a href="http://linux-wiki.cn/wiki/zh-hans/Vim%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E8%AE%BE%E7%BD%AE" title="http://linux-wiki.cn/wiki/zh-hans/Vim%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E8%AE%BE%E7%BD%AE">http://linux-wiki.cn/wiki/zh-hans/Vim%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E8%AE%BE%E7%BD%AE</a></p><p>常用设置</p><p>缩进设置最常用的是：</p><p>:filetype indent on</p><p>它将开启针对文件具体类型的缩进。</p><p>下面的选项需要在命令模式下用set设置的选项的含义。使用方法如：</p><p>set ci # 开启cindent</p><p>set noet # 关闭expandtab</p><p>set sw=4 # shiftwidth=4</p><p>上述设置可以写到~/.vimrc中：</p><p>filetype indent on</p><p>set ci</p><p>set noet</p><p>set sw=4</p><p></p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-20T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 20<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/90#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/90" itemprop="url">去掉SHELL的提示音和VI的提示音</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>SHELL：</p>
<p>用root用户打开/etc/inputrc，将下面的一行注释：</p>
<p>#set bell-style none</p>
<p>在下面添加多一行：<br />
set bell-style off</p>
<p>重新打开终端，即可生效。</p>
<p>&nbsp;</p>
<p>VI：</p>
<p>打开~/.vimrc（如果打不到该文件，可以自己创建一个），往里面添加多一行：</p>
<p>set vb t_vb=<br />
下次使用vi时即可生效。</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-14T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 14<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/87#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/87" itemprop="url">(转）linux下多线程 之 Pthread_detach(pthread_self())</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><a href="http://blog.csdn.net/Lethe1989/article/details/5191165">转自：http://blog.csdn.net/Lethe1989/article/details/5191165</a></p> <p>多线程稍微看了下还能接受没想象中的难，写了个示例程序运行修改运行修改几遍后也大致明白了。<br>写个碰到的问题，记录下自己的技术之路点滴<br>pthread_detach(pthread_self())<br>linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态，<br>如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。<br>若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。<br>unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join.<br>摘自&nbsp; http://kb.cnblogs.com/a/1285801/ <p>其实简单的说就是在线程函数头加上 pthread_detach(pthread_self())的话，线程状态改变，在函数尾部直接 pthread_exit线程就会自动退出。省去了给线程擦屁股的麻烦</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-13T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 13<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/85#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/85" itemprop="url">认识和弦以及右手的练习</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>参考网站：<a href="http://v.youku.com/v_show/id_XMzE0NjUzNjAw.html">http://v.youku.com/v_show/id_XMzE0NjUzNjAw.html</a></p> <p>C和弦与Am和弦的指法：</p> <p><a href="http://www.minlh.tk/uploads/2012/08/image7.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.minlh.tk/uploads/2012/08/image_thumb7.png" width="530" height="276"></a></p> <p>C和弦与Am和弦的切换：只有中指在换弦。</p> <p>P：大拇指</p> <p>I：食指</p> <p>M：中指</p> <p>A：无名指</p> <p>右手指法：5323 | 1323</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-08-11T00:00:00-07:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2012</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blogs/79#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blogs/79" itemprop="url">（转）腾讯微信技术总监周颢：一亿用户增长背后的架构秘密</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>转自网站：<a href="http://sd.csdn.net/a/20120515/2805581.html">http://sd.csdn.net/a/20120515/2805581.html</a> <p>周颢把微信的成功归结于腾讯式的<strong>“三位一体”策略：即产品精准、项目敏捷、技术支撑。</strong>微信的成功是在三个方面的结合比较好，能够超出绝大多数同行或对手，使得微信走到比较前的位置。所谓产品精准，通俗的讲就是在恰当的时机做了恰当的事，推出了重量级功能，在合适的时间以最符合大家需求的方式推出去。他认为在整个微信的成功中，产品精准占了很大一部分权重。 <p><strong>敏捷是一种态度 敏捷就是试错</strong> <p>微信研发团队里鼓励一种<strong>试错的信仰</strong>：<strong>他们坚信，在互联网开发里，如果能够有一个团队在更短的时间内尝试了更多机会(并能改进过来)，就能有(更多的)机会胜出。</strong>敏捷是一种态度，在软件开发过程中，项目管理者都会非常忌讳“变更”这个词，但是在微信的项目运作中是不可以的。<strong>因为微信必须要容忍说哪怕在发布前的十分钟，也要允许他变更。这是非常大的挑战，因为打破了所有传统项目开发的常识。所有人都说不可能做到的，但微信做到了。研发团队所做的一切都是要给产品决策者有最大的自由度，而这个决策正是微信能够胜出的关键。</strong> <p><strong>海量系统上的敏捷 无异于悬崖边的跳舞</strong> <p>敏捷有很多困境，如果做一个单机版程序，是可以做到很敏捷的，但是<strong>腾讯正在运作的是一个海量系统，有千万级用户同时在线，在一个单独的功能上每天有百亿级的访问，同时还要保证99.95%的可用性。在海量系统上应对项目开发会有很严谨的规范，都说要尽可能少的变化，因为90%-95%的错误都是在变更中产生的，如果系统一直不变更会获得非常高的稳定度，但是微信就是要在悬崖边跳舞。</strong>微信的研发团队要做一些事情，让敏捷开发变得更简单。 <p>如何做到这一切？周颢认为，首先，必须建立起一种<strong>狂热的技术信念，就是一定是可以做到的。</strong>然后，需要用一些稳固的技术(理念)来支撑，例如<strong>大系统小做</strong>、<strong>让一切可扩展</strong>、<strong>必须有基础组件</strong>、<strong>轻松上线</strong>(灰度、灰度、再灰度；精细监控；迅速响应)&#8230;等等来支撑。 <p><strong>四大法器</strong>：<strong>大系统小做、让一切可扩展、要有基础组件、轻松上线</strong> <ul> <li>大系统小做：当设计庞大系统的时候，应该尽量分割成更小的颗粒，使得项目之间的影响是最小的。  <li>一切可扩展：在高稳定度、高性能的系统中间，为了稳定性能把它设计成不变化的系统，但为了支持敏捷需要让一切的东西都要变得可以扩展。  <li>必须建立基础组件：要解决复杂问题的时候，需要将已有的经验固化下来，固化下来的东西会成为系统中的一部分。  <li>轻松上线：当做了变化并把它从开发环境中部署到现有的运营环境中去，在这个过程中，“灰度”这个词非常关键，就是在黑和白之间的选择，必须要变成一种小规模尝试，再逐步扩展到海量过程中的一个问题。<strong></strong> <p><strong></strong></p><p></li></ul> <p><strong>大系统小做——</strong><strong>仅仅把模块变得更为清晰，这在海量系统设计开发中是不够的，还需要在物理环境上进行分离部署，出现问题的时候可以快速发现，并且在最快的情况下解决掉。</strong> <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515074813_1.jpg" width="390" height="231"> <p>大系统小做 混搭模式 <p>将不同的应用逻辑物理分割独立出来，用户注册登录、LBS逻辑、摇一摇逻辑、漂流瓶逻辑、消息逻辑独立开来。把关键的逻辑混搭在一起，当所有的逻辑部署在同一个服务器上，确实也会带来很大敏捷上的好处，因为不需要额外的考虑部署和监控的问题。<strong>在整个微信的逻辑中，可能现在已经有上百种不同的逻辑，因为会在逻辑的分割上拆分成8-10种做分离部署。</strong> <p><strong>一切可扩展——网络协议可扩展、数据存储可扩展</strong> <p>扩展的关键点有两块。一个是网络协议需要扩展，当要升级一个新功能的时候，会有一些比较大的困难，所以所有协议设计都比较向前兼容，但是向前兼容还是不够的，因为网络协议设计本身有非常多的功能也会有比较大的字段，相关的代码可能会有数千行，这一块不能通过手写方式完成。可以通过XML描述，再通过工具自动生成所有的代码，这是微信获得快速开发的一个重要的点。 <p>另外一块就是在数据存储方面是必须可扩展的。在2005年绝大多数海量系统的设计都是采用固定字段的存储，但是在现代系统中会意识到这个问题，会采用KV或者TLV的方式，微信也做了不同的设计。 <p><strong>把复杂逻辑都固化下来，成为基础软件。</strong>在微信后台会有几种不同的基础组件。大致包括： <ul> <li>Svrkit——Client/Server自动代码生成框架:10分钟搭建内部服务器  <li>LogicServer——逻辑容器：随时添加新逻辑  <li>OssAgent——监控/统计框架：所见即所得的监控报表  <li>存储组件——屏蔽容灾/扩容等复杂问题</li></ul> <p><strong>灰度、灰度、再灰度</strong> <p>在变更后的部署方式上，微信在一些规则会限定不能一次把所有的逻辑变更上去，每一次变更一小点观察到每一个环节没有问题的时候，才能布局到全网上去。<strong>微信后台每一天可以支撑超过20个后台变更，在业界来说，通常做到5个已经是比较快了，但是微信可以做到快4倍。</strong> <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515075806_1.jpg" width="450" height="242"> <p>腾讯内部的上线系统 <p>而所谓<strong>灰度发布</strong>，是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面 来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。(在腾讯，灰度发布是最常采用的发布方式之一) <p><strong>孙子兵法：古之所谓善战者，胜于易胜者也</strong> <p>常识上，解决一个复杂问题的时候，会用高明的技巧解决复杂的问题，这个不是微信团队的目标，他们追求的要做到让所有问题很自然和简单的方式解决掉。<strong>在周颢看来，微信架构的技术复杂点在四个要点：协议、容灾、轻重、监控。</strong> <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515080024_1.jpg" width="450" height="345"> <p>微信架构 <ul> <li>协议。手机终端跟后台服务器之间的交互协议，这个协议的设计是整个系统的骨架，在这一点做好设计可以使得系统的复杂度大大降低。  <li>容灾。当系统出现了若干服务器或若干支架(宕机的时候)，仍然需要让系统尽可能的提供正常的服务。  <li>轻重。如何在系统架构中分布功能，在哪一个点实现哪一个功能，代表系统中间的功能配置。  <li>监控。为系统提供一个智能仪表盘。</li></ul> <p>在协议设计上，移动互联网和常规互联网有很大的区别。首先有CMWAP和CMNET的不同，在中国现在有相当多的手机用户使用WMWAP连接，还有就是在线和离线的概念，当QQ下线的时候叫离线，当你登录的时候叫在线。但是在移动互联网这两个概念比较模糊。从微信的设计中，不管在线还是离线系统表现都应该是一致的。还有一个是连接不稳定的问题，由于手机信号强弱的变化，当时信号很好，5秒钟走到信号不好的地区，连接就必须断掉。这个中间带来不稳定的因素为协议设计带来较大困难。此外就是资费敏感的问题，因为移动互联网是按照流量计费的，这个计费会使得在协议设计中如何最小化传输的问题。最后就是高延迟的问题。 <p>对此，业界标准的解决方案：Messaging And Presence Protocol：1)<span class="caps">XMPP</span>;2)<span class="caps">SIP</span>/SIMPLE。它的优点是简单，大量开源实现。而缺点同样明显：1)流量大：状态初始化；2)消息不可靠。 <p><strong>微信在系统中做了特殊设计，叫SYNC协议，是参考Activesyec来实现的。</strong>特点首先是基于状态同步的协议，假定说收发消息本身是状态同步的过程，假定终端和服务器状态已经被迟了，在服务器端收到最新的消息，当客户端、终端向服务器对接的时候，收取消息的过程实际上可以简单的归纳为状态同步的过程，收消息以及收取你好友状态更新都是相同的。在这样的模式之下，我们会也许会把交互的模式统一化，只需要推送一个消息到达的通知就可以了，终端收到这个通知就来做消息的同步。在这样的简化模式之下，安卓和塞班都可以得到统一。这样的系统本身的实现是更为复杂的，但是获得很多额外的好处。 <p>让剩下系统实现的部分更加简单，简化了交互模式，状态同步可以通过状态同步的差值获得最小的数据变更，通过增量的传输得到最小的数据传输量。通过这样的协议设计，微信可以确保消息是稳定到达的，而且是按序到达。引用一句俗话：比它炫的没它简单，比它简单的没它快，没谁比他更快，哪怕在GPRS下，微信也能把进度条轻易推到底。 <p><strong>追求完美设计的团队不能胜任海量服务</strong> <p>在容灾之前面向最坏的思考，如果系统真的挂了，需要做一些事情，首先是防止雪崩，避免蝴蝶效应。<strong>如果关注春节订火车票就知道了，用户的请求量会因为系统服务不了而不断的重试，意味着发生雪崩的时候，系统可能会承载原先3-10倍的流量，使得所有的事情更加恶化。所以微信有很多“放雪”功能的设计。第二个词是柔性可用，在任何的系统中不要追求完美设计，追求完美设计的是团队是不能胜任海量服务的。如果在一个系统出现问题的时候，这个系统就挂了，那么这是一个不好的设计，最好的做法是提供0-1中间的选择。</strong>举一个例子，当一个用户向另外一个用户发消息的时候，可能会通过一个垃圾信息过滤的检测，如果垃圾信息过滤这个模块突然挂掉了，这个消息难道就不能达到了吗？在这样的情况下，要忽略掉这个错误，使得消息正常达到对方。要精确定位出哪一个环节是最为重要的，把不是重要的错误尽可能的忽略掉。当不能做到完美的时候，尽可能为用户提供服务。另外一个重要方面叫做“保护点前置”，最前的一个点就是终端，在手机终端上蕴埋更多的保护点，这样会为用户系统赢得更大的处理空间。如果终端具备这样的能力，会获得更大的反应空间。 <p>周颢介绍了在微信上具体容灾设计的做法。在所有的容灾中存储层的容灾是最难的，一个系统的设计分为三层：接入层、逻辑层、存储层。接入层和逻辑层的容灾都有比较成熟的方案。逻辑层的容灾相对来说比较简单，尽量不要有状态的设计，比如说当你做上一个请求的时候，会保持一些状态，要使得下一个请求发到下一个服务器。如果任何一个请求之间互相不关联的话，这个就是无状态的设计，只要做到这一点逻辑层的容灾可以随意的切换。在回到存储层本身的容灾设计上，相对来说困难一些，但是<strong>微信研发团队采用了一些技巧，叫分而治之，分离业务场景，寻求简单的设计，并不会寻求大而同一的解决方案，因为这样会使得系统的复杂度大幅度上升，而微信会尽可能把产品拆细，寻求简化的设计。</strong> <p>首先是主备容灾，这是最常见的方案。在有一些业务场景中是可以容忍最终一致性的，比如账号系统的设计，每天写入账号系统的请求是非常少的，但是访问的请求非常多，这个差异可能会达到数万倍的规模，在这样的场景下，微信会在账号系统中采用简化的方案，也可以获得比较大的稳定度。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515080736_1.jpg" width="360" height="240"> <p>SET模型＋双写 <p>第二种容灾的模式叫双写，两台Master的机器，当一台机故障的时候，另外一台机还是可以接收到写请求，当两台机交错启动的时候，会得到数据的丢失。但是有一些场景是可以容忍轻度数据丢失的，比如说会有一个存储专门记录用户终端的类型，比如说安卓还是塞班以及他们使用终端的微信版本是什么，这样的数据是可以容忍轻度数据丢失的，因为偶尔有一些丢失的话，下一次访问会把这些数据带上来，会尽快的修复所有的数据。双写也是非常简单的模式。 <p>微信的研发团队做了一个叫Simple Quorum的机制，在微信的后台中，同步协议有一个很重要的基石叫序列发生器，这样的一个序列发生器需要有极高的稳定度。首先可以看到序列号有一个特点永远是递增的，用递增方式往前推进的时候，最大的序列号就是最新的系列号。有一个毕业才加入广研的毕业生想到一个绝佳的方案，按SET分布，从2G减到200K。 <p><strong>前轻后重 功能点后移</strong> <p>周颢还谈到了轻重的概念。这个概念的提出主要是从终端本身的一些困境所带来的。首先在终端上需要表现最多的一个产品的逻辑，逻辑非常复杂，变更的成本也非常高，当需要修复的时候必须发布一个新版本，这个新版必须由自己下载才能完成，下载的成本非常高。在这样的前提下，如果手机终端产生了任何变化的时候，如果这个变化有非常大的问题就会有极大的困境，所以需要在每一个发布之前做一些充分的数据，确保不会发生致命问题。如果一旦出现致命问题难以修复，需要把关键的点从终端移到后台实现，把功能点后移，来充分发挥后台快速变更的能力。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515081038_1.jpg" width="450" height="278"> <p>接入优化：从GSLB到IP重定向 <p>在接入层的优化，速度很重要的因素，是不是能够就近接入一个最优的节点，比如说移动用户最好接入移动的节点，海外的用户可能需要寻找更佳的路由，有的时候可能无法自动做到这一点，一点是在终端上做测速，微信会通过在后台IP逆向的能力，通过后台指挥微信终端联网的能力，寻找最优的接入点。上图就是每分钟收到同一项指令曲线的报表。 <p><strong>如何解决“偷流量”的问题</strong>——当国内类微信类产品发布的时候出现一个大的问题就是“偷流量”，当用户在某一些逻辑下进行一个死循环，不断访问某一些数据，这样的死循环是非常可怕的，如果在用户不知觉的情况之下，可能会在一个小时之内偷到数10兆甚至数百兆的流量。有非常多业内的同行都需要花大量的精力解决这个问题，微信研发团队用了非常强大的方式解决它。通过在后台建立起严厉的监控系统，对每一个用户的行为做一个监控，当发现异常的时候，后台会给终端发出指令，使得微信终端在一段时间无法联网，但是可以保证用户流量不会白白的使用掉。 <p><strong>功能适配的例子——</strong>第一期微信版本发布的时候，当时没有群聊的功能，第二版发布的时候做了这个功能。当时有两个选择，对于早期版本的用户，因为不支持群聊，就无法享用到这个功能，但是微信希望提供更好的选择，想让早期不支持群聊的版本，也可以被拉到一个群里面收消息、发消息，通过后台功能的适配也能做到这个事情。 <p><strong>分而治之 把监控嵌入基础框架</strong> <p>对于一个海量系统来说，一个精密的仪表盘非常重要。监控是非常痛苦的，对于这样一个系统来说，每小时会产生数百G的监控日志。微信希望在1分钟之内监控的数据就能够显示在报表上，因为只有这样的精准和实时度才能够赢得处理故障的时间。<strong>微信会做关联统计，通过摇一摇加了好友，他们活跃度如何，过了一段时间他们的活跃度变化情况又是如何。这种需求是需要通过大量日志的关联统计来获得的。研发团队也花了一段时间来理解这个问题，发现了中间一个重要的经验叫做“鱼和熊掌不能兼得”。</strong> <p>为了让监控数值更敏感，需要把监控细化再细化，上面数据表示每一栏子系统的数据，下面这个是按微信版本号来划分的，这里的数据项是非常多。 <p>微信还需要采集一些异常的点，如果有异常的话会发布紧急的版本，尽可能快的替换它。对收发消息延时做的监控，比如说0—1秒端到端的速度，会对不同的区段做一些统计，当某一个环节出现异常的时候，通常会在中间的延时上体现出来。有一个很重要的点叫自动报警，现在有数千项的数据，不可能每一项都靠人工去看的，必须要跟自动报警相关联，微信有一些智能的算法，是不是在正常的范围内，跟历史的数值进行对比，如果有异常的话，会通过短信、邮件还有微信本身来发出报警信息。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515081321_1.jpg" width="450" height="189"> <p>把监控嵌入基础框架 <p>微信会把监控嵌入到基础框架里面去，因为并不是每一个人都会意识到在需要的地方嵌入一个监控点，所以在基础框架本身内置很重要的监控点，比如说这个表上的栏目，非常多的栏目大概会有数百项的栏目，都不需要程序员自己去写，当用基础组件搭建一个系统的时候，就可以直接观测系统数据。 <p>在谈到微信未来的技术挑战时，周颢首先希望能够让微信成为可用性99.99%的系统；设计出面向现在10倍容量的系统以及完全的IDC容灾。 <p><img border="0" alt="" src="http://articles.csdn.net/uploads/allimg/120515/6_120515081630_1.jpg" width="450" height="537"> <p>网上盛传的凌晨两点，腾讯大厦那多层大片大片的灯光和楼下那长长的出租车队伍说明了一切。引用一句话做结尾，可怕的不是微信，真正可怕的是，比你领先比你更有天赋的团队比你更努力。 <p>附录：腾讯微信技术总监周颢演讲<a href="http://download.csdn.net/detail/java060515/4302512">PPT下载</a></p>
		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/5/" class="prev">Prev</a>
    
    
        <a href="/blog/page/7/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Mr.Liao


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	

<script type="text/javascript">
      var disqus_shortname = 'minlh';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










</body>
</html>
