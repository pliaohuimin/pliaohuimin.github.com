
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Min's Lounger</title>
	<meta name="author" content="Mr.Liao">

	
	<meta name="description" content="Nov 17th, 2014 IT Comments 各智能指针对比 std::auto_ptr 复制行为：原来指针变成null,而复制所得的指针将取得资源的唯一拥有权 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
#include &lt;stdio &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Min's Lounger" type="application/atom+xml">
	
	<link rel="canonical" href="http://pliaohuimin.github.io/blog/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("pliaohuimin@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>
<h1><a href="/">Min's Lounger</a></h1>
<p class="subtitle">All Life Sucks,all we can do is let it suck less</p>

<nav id="main-nav"><ul class="main">
    <li><a href="/blog">Blog</a></li>
    <li><a href="/blog/categories/travelling">Travelling</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:pliaohuimin@gmail.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-11-17T16:56:00+08:00" data-updated="true" itemprop="datePublished">Nov 17<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/it/'>IT</a>


</div>
		
			<span class="comments"><a href="/blog/20141117/smart-pointer/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20141117/smart-pointer/" itemprop="url">各智能指针对比</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>std::auto_ptr</h3>

<ul>
<li>复制行为：原来指针变成null,而复制所得的指针将取得资源的唯一拥有权</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;memory&gt;                                                                                                               </span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'>    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s value:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s addr:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;b&#39;s addr:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s addr:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>boost::shared_ptr</h3>

<ul>
<li>复制行为：添加引用数</li>
<li>删除时机：离开作用域时，引用数减一。没人指向它时（即引用数为0时），删除对象</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/shared_ptr.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'>    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s value:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s addr:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s use_count:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;b&#39;s addr:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s addr:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;a&#39;s use_count:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;b&#39;s use_count:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>boost::scoped_ptr</h3>

<ul>
<li>复制行为：不能拷贝</li>
</ul>


<h3>boost::weak_ptr</h3>

<ul>
<li>用途：weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。防止循环引用。</li>
<li>复制行为：weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</li>
<li>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它更像是shared_ptr的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-28T20:03:00+08:00" data-updated="true" itemprop="datePublished">Oct 28<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/effective-c-plus-plus/'>effective_c++</a>


</div>
		
			<span class="comments"><a href="/blog/20141028/effective-c-plus-plus-item17/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20141028/effective-c-plus-plus-item17/" itemprop="url">Effective_c++:item17 在独立语句中将new出来的对象存放在智能指针中</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>考虑一下代码：</p>

<blockquote><pre><code>int priority();
void processWidget( std::tr1::shared_ptr&lt;Widget&gt; pw, int priority );
processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());
</code></pre></blockquote>

<p>在调用processWidget之前，编译器必须生成代码来完成下面三个事情：
&ndash; 调用priority
&ndash; 执行new Widget
&ndash; 调用 tr1::shared_ptr 构造函数</p>

<p>我们只能确保&#8221;new Widget&#8221;会在调用tr1::shared_ptr构造函数前被调用，但priority的调用会在第一，第二还是第三，我们是无法确定的。如果priority的调用是在第二，即：
&ndash; 执行new Widget
&ndash; 调用priority
&ndash; 调用 tr1::shared_ptr 构造函数</p>

<p>请考虑一下在调用priority时抛出异常，会出现什么情况。这种情况下，依旧会出现资源泄露。</p>

<p>想避免类似问题，方法也很简单：使用独立的语句来创建Widget并将它保存在智能指针中。然后再把智能指针传递给processWidget:</p>

<blockquote><pre><code>std::tr1::shared_ptr&lt;Widget&gt; pw( new Widget);
processWidget(pw,priority());
</code></pre></blockquote>

<h3>Things to Remember</h3>

<ul>
<li>在独立语句中，将new出来的对象保存在智能指针中。不这么做的话，一旦有异常抛出，可能会导致资源泄露。</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-28T20:03:00+08:00" data-updated="true" itemprop="datePublished">Oct 28<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/effective-c-plus-plus/'>effective_c++</a>


</div>
		
			<span class="comments"><a href="/blog/20141028/effective-c-plus-plus-item16/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20141028/effective-c-plus-plus-item16/" itemprop="url">Effective_c++:item16 使用new和delete时应保持用法一致</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>当你使用new时，会发生两件事情，一个是分配内存，另一个是调用一个或者多个的构造函数。当你使用delete时，会发现另外两件事情，一个或者多个析构函数被调用，然后是内存空间的释放。这个涉及到一个问题，该删除多少个对象，这问题会决定多少个析构函数被调用。</p>

<p>实际上，这问题很简单：删除时指定是删除单个对象或者是一个数组。这个问题很重要，因为单对象的内存布局和数组对象的内存布局是不一样的。</p>

<p>规则很简单：如果你在new表达式中使用了[]，必须在delete中也使用[]。如果你在new中没使用[]，那么在delete中也不要使用[]。</p>

<p>在使用typedef时，需要特别注意，因为它意味着typedef的作者必须明文说明使用哪个形式的delete。来看看下面的例子：</p>

<blockquote><pre><code>typedef std::string AddressLines[4];
std::string *pal = newAddressLines;
</code></pre></blockquote>

<p>这时，必须使用数组形式的delete：</p>

<blockquote><pre><code>delete pal; //undefined
delete [] pal; //fine
</code></pre></blockquote>

<p>避免这个问题也很简单，方法就是使用C++库的string和vector。</p>

<h3>Things to Remember</h3>

<ul>
<li>如果你在new表达式中使用了[]，必须在delete中也使用[]。如果你在new中没使用[]，那么在delete中也不要使用[]。</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-28T20:02:00+08:00" data-updated="true" itemprop="datePublished">Oct 28<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/effective-c-plus-plus/'>effective_c++</a>


</div>
		
			<span class="comments"><a href="/blog/20141028/effective-c-plus-plus-item15/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20141028/effective-c-plus-plus-item15/" itemprop="url">Effective_c++:item15 在资源管理类中提供原资源的存取接口</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>很多时候，APIs要求原资源作为参数，这时，你需要一种能将RAII类转换成原资源的途径。一般有两种方法：显性转换和隐性转换。</p>

<p>tr1::shared_ptr和auto_ptr都提供了一个get的成员方法来实现转换，返回智能指针指向对象的祼指针：</p>

<blockquote><p>int days = daysHeld(pInv.get());</p></blockquote>

<p>一般智能指针中都重载了->和*操作，这允许了隐性转换。</p>

<p>采用显性转换时（如get()），有时用户觉得使用起来不方便，就懒得使用资源管理类。使用隐性转换（如重载()操作符）会使API的调用看起来比较简单和自然。</p>

<p>但这会增加犯错的机会。</p>

<blockquote><pre><code>FontHandle getFont();
Font f1(getFont());
...
FontHandle f2 = f1; // meant to copy a Font object, but insterad implicitly converted f1 into its underlying FontHandle,then copy that
</code></pre></blockquote>

<p>现在一个FontHandle被f1管理着，但同时FontHandle也被f2使用。这几乎从来都不是什么好兆头。例如，当f1销毁时，资源会被释放，而f2则悬挂着，指向非法空间。</p>

<p>使用显性还是隐性转换，取决于具体的使用场景。一般来说，显性转换更好些，因为它能尽可能地减少在你不想转换时被转换的机会。</p>

<p>RAII类返回原资源是对封装的破坏，但可能并不是设计上的灾难。RAII类不是用来封装某些东西的。它们的存在是为了确保一个特定的行为（如资源释放）的发生。像大部分设计得好的类，它隐藏了用户不需要看到的部分，但也提供给用户对需要存取的数据的接口。</p>

<h3>Things to Remember</h3>

<ul>
<li>APIs经常要求原资源，所以每个RAII类都必须提供一个获取它管理的原资源的方法。</li>
<li>存取方法可以通过显性或者隐性的转换。一般来说，显性更安全些，但隐性对用户来说更加方便。</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-28T20:01:00+08:00" data-updated="true" itemprop="datePublished">Oct 28<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/effective-c-plus-plus/'>effective_c++</a>


</div>
		
			<span class="comments"><a href="/blog/20141028/effective-c-plus-plus-item14/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20141028/effective-c-plus-plus-item14/" itemprop="url">Effective_c++:item14 认真考虑资源管理类的拷贝行为</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>有时，我们需要创建自己的资源管理类。
例如，你希望通过C API来操作锁对象的加锁和解锁功能。</p>

<blockquote><p>void lock(Mutex<em> pm);
void unlock(Mutex</em> pm);</p></blockquote>

<p>为了确保你不会忘记对已经加锁的对象解锁，你想创建一个类来管理锁。基本需求就是在该类的构造函数中加锁，在析构函数中解锁：</p>

<blockquote><pre><code>class Lock {
    public:
        explicit Lock(Mutex* pm): mutexPtr(pm)
        {
            lock(mutexPtr);
        }
        ~Lock() { unlock(mutexPtr); }
    private:
        Mutex* mutexPtr;
};
</code></pre></blockquote>

<p>用户使用RAII风格来使用Lock：</p>

<blockquote><pre><code>Mutex m;
{
    Lock ml(&amp;m);
    ...
}
</code></pre></blockquote>

<p>这运行得很好，但是当锁被拷贝时呢？</p>

<blockquote><pre><code>Lock ml1(&amp;m);
Lock ml2(ml1);
</code></pre></blockquote>

<p>这是类的编写者需要考虑的问题：当一个RAII对象被拷贝时，应该如何处理？大部分情况下，你会选用以下几个方式的一个来处理：
&ndash; 禁止拷贝。如果RAII对象拷贝没有意义时，你应该这么做。
&ndash; 记录资源引用数，当最后一个引用对象析构时才释放资源。</p>

<p>tr1::shared_ptr允许指定一个&#8221;deleter&#8221;&mdash;当引用数量为0时，调用指定函数或者函数对象。</p>

<blockquote><pre><code>class Lock{
public:
    explict Lock(Mutex* pm):mutexPtr(pm,unlock)
    {
        lock(mutexPtr.get());
    }
private:
    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;
};
</code></pre></blockquote>

<ul>
<li><p>对资源进行深拷贝。当你想拥有多个资源的拷贝，采用资源管理类只是为了确保每个资源都会被释放时，可以对管理的资源对象进行深拷贝。</p></li>
<li><p>移交控制权。如<em>auto_ptr</em>，拷贝方法（构造函数或者拷贝赋值操作）可能由编译器生成，如果这不是你想要的版本，你需要重写它们。</p></li>
</ul>


<h3>Things toRemember</h3>

<ul>
<li>资源的拷贝行为决定了RAII对象的拷贝行为</li>
<li>常见的RAII类拷贝行为为不允许拷贝和使用引用计数的方式，但也有一些其它的选择。</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-10-28T19:35:00+08:00" data-updated="true" itemprop="datePublished">Oct 28<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/effective-c-plus-plus/'>effective_c++</a>


</div>
		
			<span class="comments"><a href="/blog/20141028/effective-c-plus-plus-item13/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20141028/effective-c-plus-plus-item13/" itemprop="url">Effective_c++:item13 使用对象来管理资源</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>问题</h2>

<p>有一个基类：</p>

<blockquote><p>class Investment {&hellip;};</p></blockquote>

<p>通过工厂函数来提供Investment实例：</p>

<blockquote><p>Investment* createInvestment();</p></blockquote>

<p>这样一来，createInvestment的调用者在使用完该函数提供的对象指针后，需要负责把它delete掉。</p>

<p>考虑以下的使用场景：</p>

<blockquote><pre><code>void f()
{
    Investment* pInv = createInvestment();
    ....  // some code
    delete pInv;
}
</code></pre></blockquote>

<p>以下场景会导致删除pInv失败：
&ndash; f函数在&hellip;中返回
&ndash; f函数在&hellip;中抛出异常</p>

<p>当然，细心地编程能够避免以上错误的发生。但代码在经过几次的修改后呢？在软件的维护过程中，有人可能会在中间添加新的return或者continue而没有很好地处理资源问题。更糟糕的是，在&hellip;部分以前可能没有使用异常机制，突然有人觉得应该加入以提高性能。简单地依赖于人员记得去删除资源是不可行的。</p>

<h3>解决方案一</h3>

<p>为了确定获得createInvestment返回的资源总能被释放，我们需要把资源放进一个对象中，该对象的析构函数总能自动地释放该资源。</p>

<p>很多用堆动态分配出来的资源，只用于一个特定的代码块中，当控制流离开代码块或者函数时，需要被释放。标准库的<em>auto_ptr</em>就是为这种场景量身定制的。<em>auto_ptr</em>是一个类指针对象，它的析构函数会自动删除它指向的资源。下面是如何使用<em>auto_ptr</em>来避免f函数潜在的内存泄露问题：</p>

<blockquote><pre><code>void f()
{
    std::auto_ptr&lt;Investment&gt; pInv(createInvestment());
...
}
</code></pre></blockquote>

<p>这个简单的例子展示了用对象来管理资源中两个关键概念：</p>

<p>资源总是在获取时立即放进资源管理对象中。上面例子中，资源中由<em>createInvestment()返回时，被用来初始化管理它的</em>auto_ptr*对象。这种方法叫做资源获得即初始化（RAII），因为在获得一个资源的同时，又初始化了资源管理的对象。有时资源是通过赋值传给资源管理对象。</p>

<p>由于<em>auto_ptr</em>对象析构时总会删除它指向的对象，很重要的一点就是需要保证不能有多于1个的<em>auto_ptr</em>指向同一个对象。不然，对象就会被删除超过一次。为了防止类似问题，<em>auto_ptr</em>有一个特性：对资源管理对象进行拷贝操作时，会把原来的管理对象设置为null的，也就是说，资源管理对象从原来对象转移到新的资源管理对象。</p>

<blockquote><pre><code>std::autoptr&lt;Investment&gt; pInv1(createInvestment());  //pInv1 points to the objct return from createInvestment
std::autoptr&lt;Investment&gt; pInv2(pInv1); //pInv2 now points to the object;pInv1 is now null
pInv2 = pInv2; //now pInv1 points to the object,and pInv2 is null
</code></pre></blockquote>

<p>这种拷贝特性意味着<em>auto_ptr</em>没法很好地管理所有的动态分配资源。例如STL容器要求它们的内容必须有正常的拷贝行为表现。</p>

<h3>解决方案二</h3>

<p>另外一个替换方案就是reference-counting smart pointer(RCSP)。然而<em>RSCP</em>无法处理循环引用 的问题（例如，两个没用的对象互相指向对方）。</p>

<p>TR1的tr1::shared_ptr就是一个RCSP。所以你可以这样写：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());
    ...
}
</code></pre></blockquote>

<p>代码看起来和使用<em>auto_ptr</em>一样，但拷贝<em>shared_ptr</em>的行为看起来自然一些：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv1(createInvestment()); //pInv1 points to the objct return from createInvestment
    std::tr1::shared_ptr&lt;Investment&gt; pInv2(pInv1);  //both pInv1 and pInv2 now point to the object
    pInv1 = pInv2;  // nothing changed
    ...
}
</code></pre></blockquote>

<p>由于<em>shraed_ptr</em>工作起来与STD容器所期望的一致，它能在STL容器中使用。</p>

<p><em>auto_ptr</em>和<em>tr1::shared_ptr</em>都在析构函数中使用了<em>delete</em>而不是<em>delete []</em>，这意味着无法使用它们来释放数组资源。</p>

<p>如果你想处理数组对象，你可以使用<em>boost::scoped_array</em>和<em>boost:shared_array</em>。</p>

<h3>Thigns to Remember</h3>

<ul>
<li>以防止资源泄露，在RAII对象构造函数中来获取资源，在它的析构函数中来释放资源。</li>
<li>两个有用的RAII类是TR1::shared_ptr和auto_ptr，通常来说，需要拷贝时，TR1::shared_ptr是更好的选择。拷贝auto_ptr会把原来的设置为null。</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-09T14:20:00+08:00" data-updated="true" itemprop="datePublished">Sep 9<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/it/'>IT</a>


</div>
		
			<span class="comments"><a href="/blog/20140909/use-doxygen/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20140909/use-doxygen/" itemprop="url">使用Doxygen生成文档</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>在写代码时，使用doxygen vim插件生成特定格式的说明。</h4>

<h4>进入项目目录（test为例说明） cd test/</h4>

<h4>生成配置文件                          Doxygen –g</h4>

<p>note: 默认生成的配置文件名为 &ldquo;Doxyfile&#8221;，也可以采用 &#8220;doxygen -g your-cfg-filename&rdquo; 命令格式指定所生成的配置文件名。如无特殊需要，采用默认的配置文件名即可。</p>

<h4>配置文件的相应设置 ，这里已经有个模板Doxyfile(test文件夹下)，可以根据需要更改相应设置</h4>

<ul>
<li><p>项目名称，将作为于所生成的程序文档首页标题</p>

<blockquote><p>PROJECT_NAME           = Test</p></blockquote></li>
<li><p>文档版本号，可对应于项目版本号，譬如 svn、cvs 所生成的项目版本号</p>

<blockquote><p>PROJECT_NUMBER       = 1.0.0</p></blockquote></li>
<li><p>程序文档输出目录</p>

<blockquote><p>OUTPUT_DIRECTORY    =  doc/</p></blockquote></li>
<li><p>程序文档语言环境</p>

<blockquote><p>OUTPUT_LANGUAGE    = Chinese</p></blockquote></li>
<li><p>如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式</p>

<blockquote><p>OPTIMIZE_OUTPUT_FOR_C  = YES</p></blockquote></li>
<li><p>对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化</p>

<blockquote><p>TYPEDEF_HIDES_STRUCT   = YES</p></blockquote></li>
<li><p>在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YES</p>

<blockquote><p>HIDE_SCOPE_NAMES        = YES</p></blockquote></li>
<li><p>让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息</p>

<blockquote><p>QUIET   = YES</p></blockquote></li>
<li><p>只对头文件中的文档化信息生成程序文档</p>

<blockquote><p>FILE_PATTERNS          = *.h</p></blockquote></li>
<li><p>递归遍历当前目录的子目录，寻找被文档化的程序源文件</p>

<blockquote><p>RECURSIVE              = YES</p></blockquote></li>
<li><p>示例程序目录</p>

<blockquote><p>EXAMPLE_PATH           = example/</p></blockquote></li>
<li><p>示例程序的头文档 (.h 文件) 与实现文档 (.c 文件) 都作为程序文档化对象</p>

<blockquote><p>EXAMPLE_PATTERNS       = <em>.c </em>.h</p></blockquote></li>
<li><p>递归遍历示例程序目录的子目录，寻找被文档化的程序源文件</p>

<blockquote><p>EXAMPLE_RECURSIVE      = YES</p></blockquote></li>
<li><p>允许程序文档中显示本文档化的函数相互调用关系</p>

<blockquote><p>REFERENCED_BY_RELATION = YES
REFERENCES_RELATION    = YES
REFERENCES_LINK_SOURCE = YES</p></blockquote></li>
<li><p>不生成 latex 格式的程序文档</p>

<blockquote><p>GENERATE_LATEX         = NO</p></blockquote></li>
<li><p>在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包</p>

<blockquote><p>HAVE_DOT               = YES
CALL_GRAPH            = YES
CALLER_GRAPH        = YES</p></blockquote></li>
<li><p>让doxygen从配置文件所在的文件夹开始，递归地搜索所有的子目录及源文件</p>

<blockquote><p>RECURSIVE = YES</p></blockquote></li>
<li><p>在最后生成的文档中，把所有的源代码包含在其中</p>

<blockquote><p>SOURCE BROWSER = YES</p></blockquote></li>
<li><p>这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系</p>

<blockquote><p>GENERATE TREEVIEW ＝ ALL</p></blockquote></li>
</ul>


<h4>程序文档生成</h4>

<p>现在开始生成程序文档，将终端的工作目录定位在 test 目录，然后键入：</p>

<blockquote><p>$ doxygen    your-cfg-filename</p></blockquote>

<p>your-cfg-filename 是  Doxygen 配置文件名，如果是使用 &ldquo;doxygen -g&rdquo; 生成的配置文件——Doxyfile，那么可以在终端里仅键入 &ldquo;doxygen&rdquo; 命令即可生成程序文档。<br/>
生成的文档位于 test/doc/html 目录中，使用浏览器打开该目录中的 index.html 文件，即可看到自己的工作成果。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-04T16:59:00+08:00" data-updated="true" itemprop="datePublished">Sep 4<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/travelling/'>Travelling</a>


</div>
		
			<span class="comments"><a href="/blog/20140904/20140514-chufa/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20140904/20140514-chufa/" itemprop="url">2014云南之旅&#8211;出发</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>关于这趟旅行</h4>

<p>这完全是一次意外之旅。由于上层领导与股东的问题，公司在五月初宣布解散。在打包东西回住处的路上，同事问我有什么打算。突然心血来潮地决定出去旅游。刚好前阵子和还在说想自己出去走走，趁着回家休息，跟他提起想去云南旅游。三天的时间，决定一起出行。在网上定好机票，规划了整体路线，回广州办理一些工作上的手续就出发。</p>

<h4>必带物品</h4>

<p>防晒霜<br/>
保湿用品<br/>
防晒帽子<br/>
外套（昼夜温差大）<br/>
身份证<br/>
学生证（有的话）</p>

<h4>20140514</h4>

<p>早上回公司办理完手续，回去打包。在网上订的云南版LP刚好拿到手。这次旅行来得比较突然，没有做什么功课，全程就只靠这本书了。<br/>
下午五点五十分就从火车东站出发，六点半左右到达机场南站，到深航M窗口办理登机手续，队伍不是很长，十多分钟就办理完。不过这次电脑办不了托运，只能带着包登机，打火机过不了安检，洗发水居然没事。七点十来分到达登记窗口却被告知飞机晚点，九点二十分才登机，汗。登记后，又继续在飞机上发霉，十点出头才真正起飞 。<br/>
十二点左右才到达昆明长水机场。比较顺利地搭上了的，打表96元到达中凰酒店附近舍友的住处。一切打点完毕，已是凌晨两点。明天去东川，得早起，OMG。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-11T15:57:00+08:00" data-updated="true" itemprop="datePublished">Aug 11<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/webbuilding/'>WebBuilding</a>


</div>
		
			<span class="comments"><a href="/blog/20140811/add-profilepic/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20140811/add-profilepic/" itemprop="url">添加博客头像</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>新安装了<a href="https://github.com/shashankmehta/greyshade">greyshade</a>主题。</p>

<p>好奇于其他使用这个主题的其它博客，有头像的展示。一直找不到在哪设置。
原来还有<a href="http://en.gravatar.com/">gravatar</a>这种东西，通过邮箱来显示头像。只要设置好邮箱，并在gravatar服务上注册相应邮箱，上传头像就可以了。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-08T14:01:00+08:00" data-updated="true" itemprop="datePublished">Aug 8<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/webbuilding/'>WebBuilding</a>


</div>
		
			<span class="comments"><a href="/blog/20140808/new-domain/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20140808/new-domain/" itemprop="url">申请了新域名</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>今天下定决心买了域名：<a href="http://www.minlh.com/">http://www.minlh.com/</a></p>

<p>之前用的是.tk免费域名，但总觉得打开页面很卡，不知道跟域名是否有关,还是使用github的原因。
可是打开github时也不觉得特别卡，考虑一下，觉得还是买个.com的域名比较靠谱些，反正也不算太贵。</p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Mr.Liao


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	

<script type="text/javascript">
      var disqus_shortname = 'minlh';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










</body>
</html>
