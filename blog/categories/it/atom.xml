<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: IT | Min's Lounger]]></title>
  <link href="http://pliaohuimin.github.io/blog/categories/it/atom.xml" rel="self"/>
  <link href="http://pliaohuimin.github.io/"/>
  <updated>2014-10-30T11:16:13+08:00</updated>
  <id>http://pliaohuimin.github.io/</id>
  <author>
    <name><![CDATA[Mr.Liao]]></name>
    <email><![CDATA[pliaohuimin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Doxygen生成文档]]></title>
    <link href="http://pliaohuimin.github.io/blog/20140909/use-doxygen/"/>
    <updated>2014-09-09T14:20:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20140909/use-doxygen</id>
    <content type="html"><![CDATA[<h4>在写代码时，使用doxygen vim插件生成特定格式的说明。</h4>

<h4>进入项目目录（test为例说明） cd test/</h4>

<h4>生成配置文件                          Doxygen –g</h4>

<p>note: 默认生成的配置文件名为 &ldquo;Doxyfile"，也可以采用 "doxygen -g your-cfg-filename&rdquo; 命令格式指定所生成的配置文件名。如无特殊需要，采用默认的配置文件名即可。</p>

<h4>配置文件的相应设置 ，这里已经有个模板Doxyfile(test文件夹下)，可以根据需要更改相应设置</h4>

<ul>
<li><p>项目名称，将作为于所生成的程序文档首页标题</p>

<blockquote><p>PROJECT_NAME           = Test</p></blockquote></li>
<li><p>文档版本号，可对应于项目版本号，譬如 svn、cvs 所生成的项目版本号</p>

<blockquote><p>PROJECT_NUMBER       = 1.0.0</p></blockquote></li>
<li><p>程序文档输出目录</p>

<blockquote><p>OUTPUT_DIRECTORY    =  doc/</p></blockquote></li>
<li><p>程序文档语言环境</p>

<blockquote><p>OUTPUT_LANGUAGE    = Chinese</p></blockquote></li>
<li><p>如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式</p>

<blockquote><p>OPTIMIZE_OUTPUT_FOR_C  = YES</p></blockquote></li>
<li><p>对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化</p>

<blockquote><p>TYPEDEF_HIDES_STRUCT   = YES</p></blockquote></li>
<li><p>在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YES</p>

<blockquote><p>HIDE_SCOPE_NAMES        = YES</p></blockquote></li>
<li><p>让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息</p>

<blockquote><p>QUIET   = YES</p></blockquote></li>
<li><p>只对头文件中的文档化信息生成程序文档</p>

<blockquote><p>FILE_PATTERNS          = *.h</p></blockquote></li>
<li><p>递归遍历当前目录的子目录，寻找被文档化的程序源文件</p>

<blockquote><p>RECURSIVE              = YES</p></blockquote></li>
<li><p>示例程序目录</p>

<blockquote><p>EXAMPLE_PATH           = example/</p></blockquote></li>
<li><p>示例程序的头文档 (.h 文件) 与实现文档 (.c 文件) 都作为程序文档化对象</p>

<blockquote><p>EXAMPLE_PATTERNS       = <em>.c </em>.h</p></blockquote></li>
<li><p>递归遍历示例程序目录的子目录，寻找被文档化的程序源文件</p>

<blockquote><p>EXAMPLE_RECURSIVE      = YES</p></blockquote></li>
<li><p>允许程序文档中显示本文档化的函数相互调用关系</p>

<blockquote><p>REFERENCED_BY_RELATION = YES
REFERENCES_RELATION    = YES
REFERENCES_LINK_SOURCE = YES</p></blockquote></li>
<li><p>不生成 latex 格式的程序文档</p>

<blockquote><p>GENERATE_LATEX         = NO</p></blockquote></li>
<li><p>在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包</p>

<blockquote><p>HAVE_DOT               = YES
CALL_GRAPH            = YES
CALLER_GRAPH        = YES</p></blockquote></li>
<li><p>让doxygen从配置文件所在的文件夹开始，递归地搜索所有的子目录及源文件</p>

<blockquote><p>RECURSIVE = YES</p></blockquote></li>
<li><p>在最后生成的文档中，把所有的源代码包含在其中</p>

<blockquote><p>SOURCE BROWSER = YES</p></blockquote></li>
<li><p>这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系</p>

<blockquote><p>GENERATE TREEVIEW ＝ ALL</p></blockquote></li>
</ul>


<h4>程序文档生成</h4>

<p>现在开始生成程序文档，将终端的工作目录定位在 test 目录，然后键入：</p>

<blockquote><p>$ doxygen    your-cfg-filename</p></blockquote>

<p>your-cfg-filename 是  Doxygen 配置文件名，如果是使用 &ldquo;doxygen -g&rdquo; 生成的配置文件——Doxyfile，那么可以在终端里仅键入 &ldquo;doxygen&rdquo; 命令即可生成程序文档。<br/>
生成的文档位于 test/doc/html 目录中，使用浏览器打开该目录中的 index.html 文件，即可看到自己的工作成果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reactor parttern]]></title>
    <link href="http://pliaohuimin.github.io/blogs/137"/>
    <updated>2012-12-05T00:00:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blogs/137</id>
    <content type="html"><![CDATA[<p><strong>handle(句柄):</strong></p>


<p> <p>一个网络连接或文件描述符可视为一个句柄。我们需要监听的发生在这些句柄上的事件。</p> <p>&nbsp;</p> <p><strong>synchronous event demultiplexer（同步事件复用器）</strong></p> <p>用于阻塞式监听我们关心的一系列句柄。当我们关心的事件发生在相关句柄上时，会返回。一个常用的I/O事件复用器是select系统调用。</p> <p>&nbsp;</p><strong>initiation dispatcher(分发器）</strong>  <p>提供注册，删除接口，并负责派发Event Handler。上面的Synchronous Event Demultiplexer等待事件的发生，当检测到新的事件，就把事件交给Initiation Dispatcher，它去回调相应的Event Handler。</p> <p><strong>event handler(事件处理接口)</strong></p> <p>定义一个抽象接口，包含一个钩子方法，实现特定服务的派发操作。钩子方法必须由具体业务去实现。</p> <p><strong>concrect event handler(具体处理接口）</strong></p> <p>继承上面的类，根据具体的业务实现钩子方法。业务应用注册concrect event handler到initiation dispatcher以处理特定的事件。当这些事件发生时，initiation dispatcher会回调正确地这些钩子方法。</p> <p>&nbsp;</p> <p>reactor模式的结构组成可以通过下面的OMT类图来阐述：</p> <p><a href="http://www.minlh.tk/uploads/2012/12/reactor_omt.jpg"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="reactor_omt" border="0" alt="reactor_omt" src="http://www.minlh.tk/uploads/2012/12/reactor_omt_thumb.jpg" width="569" height="371"></a></p> <p>&nbsp;</p> <p>当业务应用注册一个concrect event handler到initiation dispatcher时，并在initiation dispatcher中指定一些它关心的事件，以便事件发生时initiation dispatcher能通知这个event handler。</p> <p>initiation dispatcher要求每个event handler回传句柄给它，这个句柄用来标识event handler。</p> <p>&nbsp;</p> <p>所有event handler注册完后，应用程序调用handle_events开始initiation dispatcher的事件循环，initiation dispatcher会使用synchronous event demultiplexer去监听这些句柄。当句柄相应的事件发生时，synchronous event demultiplexer会通知initiation dispatcher。</p> <p>initiation dispatcher触发event handler钩子方法去处理准备好的事件。事件发生时，initiation dispatcher会使用由事件源激活的handles为KEY去定位和分派相应的event handle的钩子方法。</p> <p>&nbsp;</p> <p>在reactor模式中，各组成构件与应用的交互图如下：</p> <p><a href="http://www.minlh.tk/uploads/2012/12/reactor_iteration.jpg"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="reactor_iteration" border="0" alt="reactor_iteration" src="http://www.minlh.tk/uploads/2012/12/reactor_iteration_thumb.jpg" width="515" height="300"></a></p> <p>&nbsp;</p> ## 实现： <p><strong>1：选择同步事件复用器机制</strong></p> <p>一般使用系统提供的接口，如：select。一般来说，同步事件复用器都是基于系统提供的机制，而不是由模式开发者去实现。</p> <p><strong>2：开发initiation dispatcher</strong></p> <p>下面是开发initiation dispatcher的必要步骤：</p> <ul> <li>实现event handler表：</li></ul> <p>initiation dispatcher维护着一张concrecte event handler。initiation dispatcher要提供注册和删除event handler的接口。</p> <ul> <li>实现事件循环进入点：</li></ul> <p>这个进入点提供handle_events的接口，此接口使用synchronous event demultiplexer负责handle的复用，和实行event handler的派发。</p> <p>&nbsp;</p> <ul> <li>处理好必要的同步机制：</li></ul> <p>要考虑同一个initiation dispatcher给多个线程同时使用的同步问题</p> <p><strong>3：确定派发目标的类型：</strong></p> <p>event handle objects:使用对象</p> <p>event handle functions:使用函数</p> ## 4：定义event handling 接口 <p>单方法接口：event handle只提供一个接口，内部根据事件类型switch，分派给具体的接口处理。</p> <p>多方法接口：由框架实现者根据事件类型直接调用相应的具体接口。</p> <p>&nbsp;</p> <p><strong><font color="#000000">5：确定应用程序中initiation dispatcher的数量</font></strong></p> <p>&nbsp;</p>   <p><strong><font color="#000000">6：实现concrecte event handlers</font></strong></p> <p><font color="#000000"></font></p></p>
]]></content>
  </entry>
  
</feed>
