<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: effective_c++ | Min's Lounger]]></title>
  <link href="http://pliaohuimin.github.io/blog/categories/effective-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://pliaohuimin.github.io/"/>
  <updated>2014-10-29T17:11:17+08:00</updated>
  <id>http://pliaohuimin.github.io/</id>
  <author>
    <name><![CDATA[Mr.Liao]]></name>
    <email><![CDATA[pliaohuimin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[effective_c++:item17 在独立语句中将new出来的对象存放在智能指针中]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item17/"/>
    <updated>2014-10-28T20:03:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item17</id>
    <content type="html"><![CDATA[<p>考虑一下代码：</p>

<blockquote><pre><code>int priority();
void processWidget( std::tr1::shared_ptr&lt;Widget&gt; pw, int priority );
processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());
</code></pre></blockquote>

<p>在调用processWidget之前，编译器必须生成代码来完成下面三个事情：
&ndash; 调用priority
&ndash; 执行new Widget
&ndash; 调用 tr1::shared_ptr 构造函数</p>

<p>我们只能确保"new Widget"会在调用tr1::shared_ptr构造函数前被调用，但priority的调用会在第一，第二还是第三，我们是无法确定的。如果priority的调用是在第二，即：
&ndash; 执行new Widget
&ndash; 调用priority
&ndash; 调用 tr1::shared_ptr 构造函数</p>

<p>请考虑一下在调用priority时抛出异常，会出现什么情况。这种情况下，依旧会出现资源泄露。</p>

<p>想避免类似问题，方法也很简单：使用独立的语句来创建Widget并将它保存在智能指针中。然后再把智能指针传递给processWidget:</p>

<blockquote><pre><code>std::tr1::shared_ptr&lt;Widget&gt; pw( new Widget);
processWidget(pw,priority());
</code></pre></blockquote>

<h3>Things to Remember</h3>

<ul>
<li>在独立语句中，将new出来的对象保存在智能指针中。不这么做的话，一旦有异常抛出，可能会导致资源泄露。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item16 使用new和delete时应保持用法一致]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item16/"/>
    <updated>2014-10-28T20:03:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item16</id>
    <content type="html"><![CDATA[<p>当你使用new时，会发生两件事情，一个是分配内存，另一个是调用一个或者多个的构造函数。当你使用delete时，会发现另外两件事情，一个或者多个析构函数被调用，然后是内存空间的释放。这个涉及到一个问题，该删除多少个对象，这问题会决定多少个析构函数被调用。</p>

<p>实际上，这问题很简单：删除时指定是删除单个对象或者是一个数组。这个问题很重要，因为单对象的内存布局和数组对象的内存布局是不一样的。</p>

<p>规则很简单：如果你在new表达式中使用了[]，必须在delete中也使用[]。如果你在new中没使用[]，那么在delete中也不要使用[]。</p>

<p>在使用typedef时，需要特别注意，因为它意味着typedef的作者必须明文说明使用哪个形式的delete。来看看下面的例子：</p>

<blockquote><pre><code>typedef std::string AddressLines[4];
std::string *pal = newAddressLines;
</code></pre></blockquote>

<p>这时，必须使用数组形式的delete：</p>

<blockquote><pre><code>delete pal; //undefined
delete [] pal; //fine
</code></pre></blockquote>

<p>避免这个问题也很简单，方法就是使用C++库的string和vector。</p>

<h3>Things to Remember</h3>

<ul>
<li>如果你在new表达式中使用了[]，必须在delete中也使用[]。如果你在new中没使用[]，那么在delete中也不要使用[]。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item15 在资源管理类中提供原资源的存取接口]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item15/"/>
    <updated>2014-10-28T20:02:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item15</id>
    <content type="html"><![CDATA[<p>很多时候，APIs要求原资源作为参数，这时，你需要一种能将RAII类转换成原资源的途径。一般有两种方法：显性转换和隐性转换。</p>

<p>tr1::shared_ptr和auto_ptr都提供了一个get的成员方法来实现转换，返回智能指针指向对象的祼指针：</p>

<blockquote><p>int days = daysHeld(pInv.get());</p></blockquote>

<p>一般智能指针中都重载了->和*操作，这允许了隐性转换。</p>

<p>采用显性转换时（如get()），有时用户觉得使用起来不方便，就懒得使用资源管理类。使用隐性转换（如重载()操作符）会使API的调用看起来比较简单和自然。</p>

<p>但这会增加犯错的机会。</p>

<blockquote><pre><code>FontHandle getFont();
Font f1(getFont());
...
FontHandle f2 = f1; // meant to copy a Font object, but insterad implicitly converted f1 into its underlying FontHandle,then copy that
</code></pre></blockquote>

<p>现在一个FontHandle被f1管理着，但同时FontHandle也被f2使用。这几乎从来都不是什么好兆头。例如，当f1销毁时，资源会被释放，而f2则悬挂着，指向非法空间。</p>

<p>使用显性还是隐性转换，取决于具体的使用场景。一般来说，显性转换更好些，因为它能尽可能地减少在你不想转换时被转换的机会。</p>

<p>RAII类返回原资源是对封装的破坏，但可能并不是设计上的灾难。RAII类不是用来封装某些东西的。它们的存在是为了确保一个特定的行为（如资源释放）的发生。像大部分设计得好的类，它隐藏了用户不需要看到的部分，但也提供给用户对需要存取的数据的接口。</p>

<h3>Things to Remember</h3>

<ul>
<li>APIs经常要求原资源，所以每个RAII类都必须提供一个获取它管理的原资源的方法。</li>
<li>存取方法可以通过显性或者隐性的转换。一般来说，显性更安全些，但隐性对用户来说更加方便。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item14 认真考虑资源管理类的拷贝行为]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item14/"/>
    <updated>2014-10-28T20:01:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item14</id>
    <content type="html"><![CDATA[<p>有时，我们需要创建自己的资源管理类。
例如，你希望通过C API来操作锁对象的加锁和解锁功能。</p>

<blockquote><p>void lock(Mutex<em> pm);
void unlock(Mutex</em> pm);</p></blockquote>

<p>为了确保你不会忘记对已经加锁的对象解锁，你想创建一个类来管理锁。基本需求就是在该类的构造函数中加锁，在析构函数中解锁：</p>

<blockquote><pre><code>class Lock {
    public:
        explicit Lock(Mutex* pm): mutexPtr(pm)
        {
            lock(mutexPtr);
        }
        ~Lock() { unlock(mutexPtr); }
    private:
        Mutex* mutexPtr;
};
</code></pre></blockquote>

<p>用户使用RAII风格来使用Lock：</p>

<blockquote><pre><code>Mutex m;
{
    Lock ml(&amp;m);
    ...
}
</code></pre></blockquote>

<p>这运行得很好，但是当锁被拷贝时呢？</p>

<blockquote><pre><code>Lock ml1(&amp;m);
Lock ml2(ml1);
</code></pre></blockquote>

<p>这是类的编写者需要考虑的问题：当一个RAII对象被拷贝时，应该如何处理？大部分情况下，你会选用以下几个方式的一个来处理：
&ndash; 禁止拷贝。如果RAII对象拷贝没有意义时，你应该这么做。
&ndash; 记录资源引用数，当最后一个引用对象析构时才释放资源。</p>

<p>tr1::shared_ptr允许指定一个"deleter"&mdash;当引用数量为0时，调用指定函数或者函数对象。</p>

<blockquote><pre><code>class Lock{
public:
    explict Lock(Mutex* pm):mutexPtr(pm,unlock)
    {
        lock(mutexPtr.get());
    }
private:
    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;
};
</code></pre></blockquote>

<ul>
<li><p>对资源进行深拷贝。当你想拥有多个资源的拷贝，采用资源管理类只是为了确保每个资源都会被释放时，可以对管理的资源对象进行深拷贝。</p></li>
<li><p>移交控制权。如<em>auto_ptr</em>，拷贝方法（构造函数或者拷贝赋值操作）可能由编译器生成，如果这不是你想要的版本，你需要重写它们。</p></li>
</ul>


<h3>Things toRemember</h3>

<ul>
<li>资源的拷贝行为决定了RAII对象的拷贝行为</li>
<li>常见的RAII类拷贝行为为不允许拷贝和使用引用计数的方式，但也有一些其它的选择。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item13 使用对象来管理资源]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item13/"/>
    <updated>2014-10-28T19:35:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item13</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>有一个基类：</p>

<blockquote><p>class Investment {&hellip;};</p></blockquote>

<p>通过工厂函数来提供Investment实例：</p>

<blockquote><p>Investment* createInvestment();</p></blockquote>

<p>这样一来，createInvestment的调用者在使用完该函数提供的对象指针后，需要负责把它delete掉。</p>

<p>考虑以下的使用场景：</p>

<blockquote><pre><code>void f()
{
    Investment* pInv = createInvestment();
    ....  // some code
    delete pInv;
}
</code></pre></blockquote>

<p>以下场景会导致删除pInv失败：
&ndash; f函数在&hellip;中返回
&ndash; f函数在&hellip;中抛出异常</p>

<p>当然，细心地编程能够避免以上错误的发生。但代码在经过几次的修改后呢？在软件的维护过程中，有人可能会在中间添加新的return或者continue而没有很好地处理资源问题。更糟糕的是，在&hellip;部分以前可能没有使用异常机制，突然有人觉得应该加入以提高性能。简单地依赖于人员记得去删除资源是不可行的。</p>

<h3>解决方案一</h3>

<p>为了确定获得createInvestment返回的资源总能被释放，我们需要把资源放进一个对象中，该对象的析构函数总能自动地释放该资源。</p>

<p>很多用堆动态分配出来的资源，只用于一个特定的代码块中，当控制流离开代码块或者函数时，需要被释放。标准库的<em>auto_ptr</em>就是为这种场景量身定制的。<em>auto_ptr</em>是一个类指针对象，它的析构函数会自动删除它指向的资源。下面是如何使用<em>auto_ptr</em>来避免f函数潜在的内存泄露问题：</p>

<blockquote><pre><code>void f()
{
    std::auto_ptr&lt;Investment&gt; pInv(createInvestment());
...
}
</code></pre></blockquote>

<p>这个简单的例子展示了用对象来管理资源中两个关键概念：</p>

<p>资源总是在获取时立即放进资源管理对象中。上面例子中，资源中由<em>createInvestment()返回时，被用来初始化管理它的</em>auto_ptr*对象。这种方法叫做资源获得即初始化（RAII），因为在获得一个资源的同时，又初始化了资源管理的对象。有时资源是通过赋值传给资源管理对象。</p>

<p>由于<em>auto_ptr</em>对象析构时总会删除它指向的对象，很重要的一点就是需要保证不能有多于1个的<em>auto_ptr</em>指向同一个对象。不然，对象就会被删除超过一次。为了防止类似问题，<em>auto_ptr</em>有一个特性：对资源管理对象进行拷贝操作时，会把原来的管理对象设置为null的，也就是说，资源管理对象从原来对象转移到新的资源管理对象。</p>

<blockquote><pre><code>std::autoptr&lt;Investment&gt; pInv1(createInvestment());  //pInv1 points to the objct return from createInvestment
std::autoptr&lt;Investment&gt; pInv2(pInv1); //pInv2 now points to the object;pInv1 is now null
pInv2 = pInv2; //now pInv1 points to the object,and pInv2 is null
</code></pre></blockquote>

<p>这种拷贝特性意味着<em>auto_ptr</em>没法很好地管理所有的动态分配资源。例如STL容器要求它们的内容必须有正常的拷贝行为表现。</p>

<h3>解决方案二</h3>

<p>另外一个替换方案就是reference-counting smart pointer(RCSP)。然而<em>RSCP</em>无法处理循环引用 的问题（例如，两个没用的对象互相指向对方）。</p>

<p>TR1的tr1::shared_ptr就是一个RCSP。所以你可以这样写：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());
    ...
}
</code></pre></blockquote>

<p>代码看起来和使用<em>auto_ptr</em>一样，但拷贝<em>shared_ptr</em>的行为看起来自然一些：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv1(createInvestment()); //pInv1 points to the objct return from createInvestment
    std::tr1::shared_ptr&lt;Investment&gt; pInv2(pInv1);  //both pInv1 and pInv2 now point to the object
    pInv1 = pInv2;  // nothing changed
    ...
}
</code></pre></blockquote>

<p>由于<em>shraed_ptr</em>工作起来与STD容器所期望的一致，它能在STL容器中使用。</p>

<p><em>auto_ptr</em>和<em>tr1::shared_ptr</em>都在析构函数中使用了<em>delete</em>而不是<em>delete []</em>，这意味着无法使用它们来释放数组资源。</p>

<p>如果你想处理数组对象，你可以使用<em>boost::scoped_array</em>和<em>boost:shared_array</em>。</p>

<h3>Thigns to Remember</h3>

<ul>
<li>以防止资源泄露，在RAII对象构造函数中来获取资源，在它的析构函数中来释放资源。</li>
<li>两个有用的RAII类是TR1::shared_ptr和auto_ptr，通常来说，需要拷贝时，TR1::shared_ptr是更好的选择。拷贝auto_ptr会把原来的设置为null。</li>
</ul>

]]></content>
  </entry>
  
</feed>
