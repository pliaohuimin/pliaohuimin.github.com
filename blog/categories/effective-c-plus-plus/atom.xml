<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: effective_c++ | Min's Lounger]]></title>
  <link href="http://pliaohuimin.github.io/blog/categories/effective-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://pliaohuimin.github.io/"/>
  <updated>2014-10-28T20:02:06+08:00</updated>
  <id>http://pliaohuimin.github.io/</id>
  <author>
    <name><![CDATA[Mr.Liao]]></name>
    <email><![CDATA[pliaohuimin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[effective_c++:item14 认真考虑资源管理类的拷贝行为]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item14/"/>
    <updated>2014-10-28T20:01:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item14</id>
    <content type="html"><![CDATA[<p>有时，我们需要创建自己的资源管理类。
例如，你希望通过C API来操作锁对象的加锁和解锁功能。</p>

<blockquote><p>void lock(Mutex<em> pm);
void unlock(Mutex</em> pm);</p></blockquote>

<p>为了确保你不会忘记对已经加锁的对象解锁，你想创建一个类来管理锁。基本需求就是在该类的构造函数中加锁，在析构函数中解锁：</p>

<blockquote><pre><code>class Lock {
    public:
        explicit Lock(Mutex* pm): mutexPtr(pm)
        {
            lock(mutexPtr);
        }
        ~Lock() { unlock(mutexPtr); }
    private:
        Mutex* mutexPtr;
};
</code></pre></blockquote>

<p>用户使用RAII风格来使用Lock：</p>

<blockquote><pre><code>Mutex m;
{
    Lock ml(&amp;m);
    ...
}
</code></pre></blockquote>

<p>这运行得很好，但是当锁被拷贝时呢？</p>

<blockquote><pre><code>Lock ml1(&amp;m);
Lock ml2(ml1);
</code></pre></blockquote>

<p>这是类的编写者需要考虑的问题：当一个RAII对象被拷贝时，应该如何处理？大部分情况下，你会选用以下几个方式的一个来处理：
&ndash; 禁止拷贝。如果RAII对象拷贝没有意义时，你应该这么做。
&ndash; 记录资源引用数，当最后一个引用对象析构时才释放资源。</p>

<p>tr1::shared_ptr允许指定一个"deleter"&mdash;当引用数量为0时，调用指定函数或者函数对象。</p>

<blockquote><pre><code>class Lock{
public:
    explict Lock(Mutex* pm):mutexPtr(pm,unlock)
    {
        lock(mutexPtr.get());
    }
private:
    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;
};
</code></pre></blockquote>

<ul>
<li><p>对资源进行深拷贝。当你想拥有多个资源的拷贝，采用资源管理类只是为了确保每个资源都会被释放时，可以对管理的资源对象进行深拷贝。</p></li>
<li><p>移交控制权。如<em>auto_ptr</em>，拷贝方法（构造函数或者拷贝赋值操作）可能由编译器生成，如果这不是你想要的版本，你需要重写它们。</p></li>
</ul>


<h3>Things toRemember</h3>

<ul>
<li>资源的拷贝行为决定了RAII对象的拷贝行为</li>
<li>常见的RAII类拷贝行为为不允许拷贝和使用引用计数的方式，但也有一些其它的选择。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[effective_c++:item13 使用对象来管理资源]]></title>
    <link href="http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item13/"/>
    <updated>2014-10-28T19:35:00+08:00</updated>
    <id>http://pliaohuimin.github.io/blog/20141028/effective-c-plus-plus-item13</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>有一个基类：</p>

<blockquote><p>class Investment {&hellip;};</p></blockquote>

<p>通过工厂函数来提供Investment实例：</p>

<blockquote><p>Investment* createInvestment();</p></blockquote>

<p>这样一来，createInvestment的调用者在使用完该函数提供的对象指针后，需要负责把它delete掉。</p>

<p>考虑以下的使用场景：</p>

<blockquote><pre><code>void f()
{
    Investment* pInv = createInvestment();
    ....  // some code
    delete pInv;
}
</code></pre></blockquote>

<p>以下场景会导致删除pInv失败：
&ndash; f函数在&hellip;中返回
&ndash; f函数在&hellip;中抛出异常</p>

<p>当然，细心地编程能够避免以上错误的发生。但代码在经过几次的修改后呢？在软件的维护过程中，有人可能会在中间添加新的return或者continue而没有很好地处理资源问题。更糟糕的是，在&hellip;部分以前可能没有使用异常机制，突然有人觉得应该加入以提高性能。简单地依赖于人员记得去删除资源是不可行的。</p>

<h3>解决方案一</h3>

<p>为了确定获得createInvestment返回的资源总能被释放，我们需要把资源放进一个对象中，该对象的析构函数总能自动地释放该资源。</p>

<p>很多用堆动态分配出来的资源，只用于一个特定的代码块中，当控制流离开代码块或者函数时，需要被释放。标准库的<em>auto_ptr</em>就是为这种场景量身定制的。<em>auto_ptr</em>是一个类指针对象，它的析构函数会自动删除它指向的资源。下面是如何使用<em>auto_ptr</em>来避免f函数潜在的内存泄露问题：</p>

<blockquote><pre><code>void f()
{
    std::auto_ptr&lt;Investment&gt; pInv(createInvestment());
...
}
</code></pre></blockquote>

<p>这个简单的例子展示了用对象来管理资源中两个关键概念：</p>

<p>资源总是在获取时立即放进资源管理对象中。上面例子中，资源中由<em>createInvestment()返回时，被用来初始化管理它的</em>auto_ptr*对象。这种方法叫做资源获得即初始化（RAII），因为在获得一个资源的同时，又初始化了资源管理的对象。有时资源是通过赋值传给资源管理对象。</p>

<p>由于<em>auto_ptr</em>对象析构时总会删除它指向的对象，很重要的一点就是需要保证不能有多于1个的<em>auto_ptr</em>指向同一个对象。不然，对象就会被删除超过一次。为了防止类似问题，<em>auto_ptr</em>有一个特性：对资源管理对象进行拷贝操作时，会把原来的管理对象设置为null的，也就是说，资源管理对象从原来对象转移到新的资源管理对象。</p>

<blockquote><pre><code>std::autoptr&lt;Investment&gt; pInv1(createInvestment());  //pInv1 points to the objct return from createInvestment
std::autoptr&lt;Investment&gt; pInv2(pInv1); //pInv2 now points to the object;pInv1 is now null
pInv2 = pInv2; //now pInv1 points to the object,and pInv2 is null
</code></pre></blockquote>

<p>这种拷贝特性意味着<em>auto_ptr</em>没法很好地管理所有的动态分配资源。例如STL容器要求它们的内容必须有正常的拷贝行为表现。</p>

<h3>解决方案二</h3>

<p>另外一个替换方案就是reference-counting smart pointer(RCSP)。然而<em>RSCP</em>无法处理循环引用 的问题（例如，两个没用的对象互相指向对方）。</p>

<p>TR1的tr1::shared_ptr就是一个RCSP。所以你可以这样写：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());
    ...
}
</code></pre></blockquote>

<p>代码看起来和使用<em>auto_ptr</em>一样，但拷贝<em>shared_ptr</em>的行为看起来自然一些：</p>

<blockquote><pre><code>void f()
{
    std::tr1::shared_ptr&lt;Investment&gt; pInv1(createInvestment()); //pInv1 points to the objct return from createInvestment
    std::tr1::shared_ptr&lt;Investment&gt; pInv2(pInv1);  //both pInv1 and pInv2 now point to the object
    pInv1 = pInv2;  // nothing changed
    ...
}
</code></pre></blockquote>

<p>由于<em>shraed_ptr</em>工作起来与STD容器所期望的一致，它能在STL容器中使用。</p>

<p><em>auto_ptr</em>和<em>tr1::shared_ptr</em>都在析构函数中使用了<em>delete</em>而不是<em>delete []</em>，这意味着无法使用它们来释放数组资源。</p>

<p>如果你想处理数组对象，你可以使用<em>boost::scoped_array</em>和<em>boost:shared_array</em>。</p>

<h3>Thigns to Remember</h3>

<ul>
<li>以防止资源泄露，在RAII对象构造函数中来获取资源，在它的析构函数中来释放资源。</li>
<li>两个有用的RAII类是TR1::shared_ptr和auto_ptr，通常来说，需要拷贝时，TR1::shared_ptr是更好的选择。拷贝auto_ptr会把原来的设置为null。</li>
</ul>

]]></content>
  </entry>
  
</feed>
